# 用户部分--用户模型类(Django自带)、自定义用户模型



# 一、用户模型类

Django提供了认证系统，文档资料可参考此链接https://yiyibooks.cn/xx/Django_1.11.6/topics/auth/index.html

Django认证系统同时处理认证和授权。简单地讲，认证验证一个用户是否它们声称的那个人，授权决定一个通过了认证的用户被允许做什么。 这里的词语“认证”同时指代这两项任务，即Django的认证系统同时提供了认证机制和权限机制。

Django的认证系统包含：

- 用户
- 权限：二元（是/否）标志指示一个用户是否可以做一个特定的任务。
- 组：对多个用户运用标签和权限的一种通用的方式。
- 一个可配置的密码哈希系统
- 用户登录或内容显示的表单和视图
- 一个可插拔的后台系统

Django默认提供的认证系统中，用户的认证机制依赖Session机制，我们在本项目中将引入JWT认证机制，将用户的身份凭据存放在Token中，然后对接Django的认证系统，帮助我们来实现：

- 用户的数据模型
- 用户密码的加密与验证
- 用户的权限系统

## Django用户模型类

Django认证系统中提供了用户模型类User保存用户的数据，默认的User包含以下常见的基本字段：

![1560227819931](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560227819931.png)

### 常用方法:

![1560227856925](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560227856925.png)

### 管理器方法:

管理器方法即可以通过*User.object.*进行调用的方法。

![1560227897339](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560227897339.png)

## 创建自定义的用户模型类:

Django认证系统中提供的用户模型类及方法很方便，我们可以使用这个模型类，但是字段有些无法满足项目需求，如本项目中需要保存用户的邮箱（或者手机号之类），需要给模型类添加额外的字段。

Django提供了django.contrib.auth.models.AbstractUser用户抽象模型类允许我们继承，扩展字段来使用Django认证系统的用户模型类。

在meiduo/meiduo_mall中创建Django应用users

~~~
python manage.py startapp users
~~~



**并在配置文件中注册users应用。**

~~~python
INSTALLED_APPS = [
     ...,
    'users',
]
~~~



在创建好的应用models.py中定义用户的用户模型类。

~~~python
from django.db import models
from django.contrib.auth.models import AbstractUser

# Create your models here.
class User(AbstractUser):
    mobile = models.CharField(max_length=11, unique=True, verbose_name='手机')

    class Meta:
        db_table = 'tb_users'
        verbose_name = '用户'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.username
~~~

我们自定义的用户模型类还不能直接被Django的认证系统所识别，需要在配置文件中告知Django认证系统使用我们自定义的模型类。

在配置文件中进行添加设置

~~~
AUTH_USER_MODEL = 'users.User' # AUTH_USER_MODEL 参数的设置以点.来分隔，表示应用名.模型类名。
~~~

**注意：Django建议我们对于AUTH_USER_MODEL参数的设置一定要在第一次数据库迁移之前就设置好，否则后续使用可能出现未知错误。**

执行数据库迁移:

~~~python
python manage.py makemigrations
python manage.py migrate
~~~

![1560232100153](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560232100153.png)

# 用户部分--注册业务接口分析、跨域CORS、使用celery异步完成发送短信



# 一、注册:

创建好用户模型类后，我们开始来实现第一个业务逻辑——用户注册

* 分析要实现的业务逻辑，明确在这个业务中需要涉及到几个相关子业务，将每个子业务当做一个接口来设计。
* 分析接口的功能任务，明确接口的访问方式与返回数据：
  * 接口的请求方式，如GET 、POST 、PUT等
  * 接口的URL路径定义
  * 需要前端传递的数据及数据格式（如路径参数、查询字符串、请求体表单、JSON等）
  * 返回给前端的数据及数据格式



**特别强调**：在前后端分离的应用模式中，我们作为后端开发人员设计后端接口时，可以不用考虑返回给前端数据后，前端如何处理，这是前端开发人员的工作，我们只需明确我们要保存的或者要返回的是什么数据即可。

## 2.注册业务接口分析:

![1560232445389](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560232445389.png)

在用户注册中,需要实现以下接口:

- 短信验证码;
- 用户名判断是否存在;
- 手机号判断是否存在;
- 注册保存用户数据;





# 二、短信验证码:

短信验证功能可以归属为第三方功能,所以**创建一个新应用verifications，在此应用中实现短信验证码**

~~~python
python manage.py startapp verifications
~~~



## 1. 业务处理流程:

- 1.生成和发送短信验证码;
- 2.保存短信验证码;
- 3.redis pipline的使用;
- 4.检查是否在60s内有发送记录;
- 5.celery异步发送短信;

## 2. 后端接口设计:

请求方式: GET /email_codes/(?P<email>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/
请求参数: 路径参数

| 参数  | 类型 | 是否必须说明 | 说明 |
| :---: | :--: | :----------: | :--: |
| email | str  |      是      | 邮箱 |

返回数据:json

返回值|类型|是否必传|说明
:-:|:-:|:-:|:-:
message|str|否|OK,发送成功|

## 3.后端实现:

verifications/views.py中

~~~python
import logging

from django.shortcuts import render
from django_redis import get_redis_connection

from rest_framework.views import APIView 
from rest_framework.response import Response
from rest_framework import status


# Create your views here.

logger = logging.getLogger('django')


class EmailCodeView(APIView):
    """发送邮件验证码"""
    def get(self, request, email):
        """
            发送邮件验证码
            re_path(r"^sms_codes/(?P<email>1[3-9]\d{9})/$", views.SMSCodeView.as_view()),
            :param request:
            :param mobile: 路径传参的手机号
            :return:       
        """
        # 1. 创建redis链接
        redis_conn = get_redis_connection(alias='verify_codes')

        # 2.判断60m内是否不允许重复发送短信
        email_flag_key = 'send_flag_key_%s'%email
        email_flag = redis_conn.get(email_flag_key)
        if email_flag:
            return Response({'message':'发送短信过于频繁'}, status=status.HTTP_400_BAD_REQUEST)

        # 3. 生成验证码
        import random
        send_code = random.randint(100000, 999999)
        logger.info(send_code)

        # 发送邮件，调用发送邮件接口
        import send_email
        # 发送验证码给邮箱
        #  1. 同步发送邮件
        result = send_email.send_email_code(email, 'register')
        if result:
            return Response({'message':'OK'})
        else:
            return Response({'message':'验证码发送失败，请重新发送！'}, status=status.HTTP_400_BAD_REQUEST)

~~~

但是,实现到这里,似乎一切都没有错，但是前端的请求却不能被后端接收或者接收返回给前端走的是error。

这里我们来测试下，前端文件夹有个测试页面test.html

~~~html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/jquery-1.12.4.min.js"></script>
    <script src="js/axios-0.18.0.min.js"></script>
</head>
<body>
<input type="button" value="show" id="show">
</body>
</html>
<script>
    $('#show').click(function () {
        axios.get('http://127.0.0.1:8000/test/')
            .then(response=>{
                console.log('ok')
            }).catch(error=>{
                console.log('no')
        });
    });
</script>
~~~



我们启动前端服务，进入front_end_pc执行命令live-server启动前端，输入<http://127.0.0.1:8080/test.html>

并发送请求，后端代码子目录meiduo_mall/views.py

~~~python
from django.shortcuts import render
from rest_framework.views import APIView
from rest_framework.response import Response


class TestView(APIView):
    def get(self, request):
        print('I am coming')
        return Response({'message':'接收OK'})
~~~

启动后端程序，进入根目录meiduo_mall下

~~~py
python manage.py runserver 127.0.0.1:8000
~~~

发送请求：

![1560268660832](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560268660832.png)

查看打印的日志报错CORS跨域问题

![1560269040837](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560269040837.png)原因就是我们使用前后端分离的模式, 所以需要做跨域访问。

## 4.关于跨域访问:



浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。比如我有一个A网站，我现在想通过Ajax来得到B网站上的某些内容，A和B是在不同域中，这时就会出现跨域问题。或者比如，站点 http://domain-a.com 的某 HTML 页面通过 [ 的 src ](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Img#Attributes)请求 http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。或者可以正常发起跨站请求，但是返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。

跨域资源共享（ [CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS) ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。

## 5.设置域名:

现在为前端和后端扥别设置两个不同的域名:

| 位置 |      域名      |
| :--: | :------------: |
| 前端 | www.meiduo.com |
| 后端 | api.meiduo.com |

在hosts文件中添加2调信息

~~~
127.0.0.1   api.meiduo.com
127.0.0.1   www.meiduo.com
~~~

* windows系统在`C:\Windows\System32\drivers\etc`目录中
* linux系统中`cat /etc/hosts`

# 三、跨域CORS:

我们为前端和后端分别设置了两个不同的域名

| 位置 |      域名      |
| :--: | :------------: |
| 前端 | www.meiduo.com |
| 后端 | api.meiduo.com |

**现在，前端与后端分处不同的域名，我们需要为后端添加跨域访问的支持。**
我们使用CORS来解决后端对跨域访问的支持。使用django-cors-headers扩展

#### 1. 安装:

~~~python
pip install django-cors-headers
~~~

#### 2.添加应用

~~~python
INSTALLED_APPS = [
    ...
    'corsheaders',
    ...
]
~~~

#### 3.中间件设置

~~~python
MIDDLEWARE = [
    # 注意这个放在其他中间件的最上面
   'corsheaders.middleware.CorsMiddleware',
    ...
]
~~~

#### 4.添加白名单

~~~python
# CORS
CORS_ORIGIN_WHITELIST = (  # 凡是出现在白名单中的域名，都可以访问后端接口
    'http://127.0.0.1:8080',
    'http://localhost:8080',
    'http://www.meiduo.com:8080',
    'http://api.meiduo.com:8000'
)
CORS_ALLOW_CREDENTIALS = True  # 指明在跨域访问中，后端是否支持对cookie的操作。
~~~

#### 5.测试

![1560317396520](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560317396520.png)



正常访问了。至此跨域问题得到处理；

# 四、使用celery异步完成发送短信:

## 1. celery介绍:

Celery是基于Python开发的一个分布式任务队列框架，支持使用任务队列的方式在分布的机器/进程/线程上执行任务调度。即插即用，易于使用和维护，单个进程每分钟可以处理数百万个任务。

![1560317721681](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560317721681.png)

![img](https://upload-images.jianshu.io/upload_images/9286065-b7d030bb829d75c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp)





## 2. celery的安装:

~~~python
pip install celery
~~~

## 3.celery使用:

在meiduo/meiduo_mall下(manage.py同级)创建celery_tasks用于保存celery异步任务。

* 在celery_tasks目录下创建config.py文件，用于保存celery的配置信息。

~~~python
# Broker配置，使用Redis作为消息中间件，存放broker消息队列
broker_url = "redis://127.0.0.1:6379/4"
# BACKEND配置，这里使用redis，存放执行结果
result_backend = "redis://127.0.0.1:6379/5"
~~~

* 在celery_tasks目录下创建main.py文件，用于作为celery的启动文件

~~~python
# 为celery使用django配置文件进行设置

import os
from celery import Celery

# 设置django环境，celery 运行时需要读取django中的信息
# if not os.getenv('DJANGO_SETTINGS_MODULE'):
#     os.environ['DJANGO_SETTINGS_MODULE'] = 'meiduo_mall.settings.dev

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'meiduo_mall.settings.dev')

# 创建celery应用, 创建一个Celery类的实例对象
app = Celery('meiduo')

#  导入celery配置
app.config_from_object('celery_tasks.config')

# 自动注册celery任务
app.autodiscover_tasks(['celery_tasks.email', ])
~~~

在celery_tasks目录下创建email目录，用于放置发送邮件的异步任务相关代码。

将提供的发送邮件的代码放到celery/email/send_email.py目录下

~~~python
import random
import logging

from django.core.mail import send_mail
from django_redis import get_redis_connection
from django.conf import settings

from verifications import constants


# 导入日志器
logger = logging.getLogger('django')


# 定义一个发送邮件
def send_email_code(email, email_code, send_type):


    subject = ''  # 主题
    text_message = ''  # 正文
    html_message = ''  # html格式正文

    if send_type == 'register':
        # print('register')
        subject = u'全民python-注册验证码'
        text_message = u'【全民python】您的注册验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！'.format(email_code)  # text格式
        html_message = u'【全民python】您的注册验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！'.format(email_code)  # html格式方便点击链接

    elif send_type == 'resetpwd':
        subject = u'全民python-找回密码验证码'
        text_message = u'【全民python】找回登录密码的验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！'.format(email_code)
        html_message = u'<p>【全民python】找回登录密码的验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！</p>'.format(email_code)
    else:
        subject = ''
        text_message = ''
        html_message = ''

    # # 保存缓存
    # # mcache.set_key(email, code.lower(), 120)
    # conn_redis = get_redis_connection(alias='verify_codes')

    # # 创建一个在60s以内是否有发送邮件记录的标记
    # email_flag_key = "email_flag_key_{}".format(email).encode('utf-8')

    # # 创建保存邮箱验证码的标记key
    # email_code_key = "email_code_key{}".format(email).encode('utf-8')

    # # 在此处设置为True会出现bug
    # try:
    #     # 使用redis管道pipeline，优化redis交互，减少通信次数，
    #     # 创建redis管道对象
    #     pl = conn_redis.pipeline()

    #     # 将验证码和是否发送标记存储到redis中

    #     pl.setex(email_flag_key, constants.SEND_CODE_INTERVAL, 1)  # 是否已发送标志
    #     pl.setex(email_code_key, constants.EMAIL_CODE_REDIS_EXPIRES, email_code.lower())  # 保存验证码
    #     # 让管道通知redis执行命令
    #     pl.execute()
    # except Exception as e:
    #     logger.debug("redis 执行出现异常:{}".format(e))
    #     return None

    logger.info("email code:{}".format(email_code))
    logger.info("EMAIL_FROM:{}".format(settings.EMAIL_FROM))

    send_status = send_mail(subject, text_message, settings.EMAIL_FROM, [email], html_message)  # 如果提供了html_message，可以发送带HTML代码的邮件。
    print('send_status%s' %send_status)
    return send_status


'''
1.单发send_mail()方法返回值将是成功发送出去的邮件数量（只会是0或1，因为它只能发送一封邮件）。
2.群发 send_mass_mail()，用来处理大批量邮件任务。返回值是成功发送的邮件数量。
使用send_mail()方法时，每调用一次，它会和SMTP服务器建立一次连接，也就是发一次连一次，效率很低。
而send_mass_mail()，则只建立一次链接，就将所有的邮件都发送出去，效率比较高。

需要提醒的是，接收方的邮件服务商不一定支持多媒体邮件，可能为了安全，也许是别的原因。
为了保证邮件内容能被阅读，最好2种格式一起发送纯文本邮件。
'''
~~~

在celery_tasks/email/目录下创建tasks.py文件，用于保存发送邮件的异步任务

~~~python
import logging
from meiduo_mall.celery_tasks.main import app

logger = logging.Logger('django')

# 创建任务函数
@app.task(name='send_email_code')
def task_send_email_code(email, email_code, send_type):  
    """
    发送邮件验证码的任务
    :param email:
    :param email_code:
    :return:
    """
    try:
        send_status = send_email.send_email_code(email, email_code, send_type)
    except Exception as e:
        logger.error("发送邮件验证码[异常][ email: %s, message: %s ]" % (email, e))

    else: # 如果try里面的语句可以正常执行，那么就执行else里面的语句（相当于程序没有碰到致命性错误）
        if send_status:  # 成功返回1，不成功返回0或者报错
            logger.info("发送邮件验证码[正常][ email: %s, email_code: %s ]" % (email, email_code))
        else:
            logger.warning("发送邮件验证码[失败][ email: %s ]" % email)

~~~

将调用发送邮件的地方改成celery异步发送

~~~python
class EmailCodeView(APIView):
    """发送邮件验证码"""
    def get(self, request, email):
        """
            发送邮件验证码
            re_path(r"^sms_codes/(?P<email>1[3-9]\d{9})/$", views.SMSCodeView.as_view()),
            :param request:
            :param mobile: 路径传参的手机号
            :return:       
        """
        send_type = request.query_params.dict().get('send_type')
        print(send_type)

        # 1. 创建redis链接
        redis_conn = get_redis_connection(alias='verify_codes')

        # 2.判断60m内是否不允许重复发送短信
        email_flag_key = 'email_flag_key_{}'.format(email)
        email_flag = redis_conn.get(email_flag_key)
        print(email_flag)
        if email_flag:
            return Response({'message': '发送邮件过于频繁'}, status=status.HTTP_400_BAD_REQUEST)

        # 3. 生成验证码
        if send_type == 'register':
            code_len = 6
        elif send_type == 'resetpwd':
            code_len = 6
        else:
            code_len = 4

        email_code = self.random_str(code_len)


        logger.info(email_code)

        email_code_key = 'email_code_key_{}'.format(email)
        print(email_code_key)

        # 发送邮件，调用发送邮件接口
        #from celery_tasks.email import send_email
        # 发送验证码给邮箱
        # #  1. 同步发送邮件
        # result = send_email.task_send_email_code(email, 'register')
        # if result:
        #     return Response({'message':'OK'})
        # else:
        #     return Response({'message':'验证码发送失败，请重新发送！'}, status=status.HTTP_400_BAD_REQUEST)
        # 2. 使用celery异步发送邮件，调用delay
        task_send_email_code.delay(email, email_code, send_type)

        print("邮箱验证码:%s" % email_code)       

            # 在此处设置为True会出现bug
        try:
            # 使用redis管道pipeline，优化redis交互，减少通信次数，
            # 创建redis管道对象
            pl = redis_conn.pipeline()
            
            # 将验证码和是否发送标记存储到redis中

            from verifications import constants

            pl.setex(email_flag_key, constants.SEND_CODE_INTERVAL, 1)  # 是否已发送标志
            pl.setex(email_code_key, constants.EMAIL_CODE_REDIS_EXPIRES, email_code.lower())  # 保存验证码
            # 让管道通知redis执行命令
            pl.execute()
        except Exception as e:
            logger.debug("redis 执行出现异常:{}".format(e))
            return Response({'message': 'redis 执行出现异常:{}'.format(e)})

        return Response({'message': 'OK'})

~~~



切换到项目根目录meiduo_mall下，执行命令启动worker。启动celery异步任务:

~~~
celery -A celery_tasks.main worker -l info
~~~

启动 celery 服务，通过它来监听是否有任务要处理。这个命令启动了一个worker，用来执行程序中add这个加法任务（task）。

* -A 选项指定 celery 实例 app 的位置，本例中celery_tasks.main中自动寻找，当然可以直接指定 celery worker -A task.app -l info
*  -l 选项指定日志级别， -l 是 --loglevel 的缩略形式
* 其他更多选项通过 celery worker –-help 查看

![1560356568617](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560356568617.png)

**注意** ：有个坑，当时email目录是之间建立的文件夹，而不是python包导致(即没有\__init__.py文件)导致获取任务为空。花了半个小时排查，蓦然回首，那人却在灯火阑珊处！！

发送邮件的时候报错：

![1560666905649](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560666905649.png)

win10上运行celery4.x就会出现这个问题，解决办法如下

先安装一个``eventlet`

~~~
pip install eventlet
~~~

然后启动worker的时候加一个参数，如下：

~~~
celery -A celery_tasks.main worker -l info -P eventlet
~~~





# python学习之美多商城(五):用户部分--判断账号/用户名/手机号是否重复、注册

# 一、判断账号是否存在:

## 1. 判断用户名是否存在:

**后端接口设计:**
请求方式:GET usernames/(?P<username>\w{5,20})/count/
请求参数: 路径传参

参数|类型|是否必传|说明
:-:|:-:|:-:|:-:|
username|str|是|用户名

返回数据：JSON

|  返回值  | 类型 | 是否必传 |  说明  |
| :------: | :--: | :------: | :----: |
| username | str  |    是    | 用户名 |
|  count   | int  |    是    |  数量  |

返回数据示例：

~~~
{
	"username":"qmpython",
	"count":1
}
~~~

后端代码实现：

~~~python
class CheckUsername(APIView):
    """验证用户名是否重复"""
    def get(self, request, username):
        """
        验证用户名是否重复
        path(r"usernames/(?P<username>\w{5,20})/count/",views.CheckUsername.as_view()),
        :param request:
        :param name:
        :return:
        """
        count = User.objects.filter(username=username)

        data = {
                'username': username,
                'count': count
        }

        return Response(data)
~~~

## 2. 判断邮箱是否存在

**后端接口设计:**
请求方式：GET emails/(?P<email>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$)/count/
请求参数: 路径参数

| 参数  | 类型 | 是否必传 | 说明 |
| :---: | :--: | :------: | :--: |
| email | str  |    是    | 邮箱 |

返回数据：JSON

| 返回值 | 类型 | 是否必传 | 说明 |
| :----: | :--: | :------: | :--: |
| email  | str  |    是    | 邮箱 |
| count  | int  |    是    | 数量 |

返回数据示例：

~~~
{
	"email":"44@qq.com",
	"count":0
}

~~~

后端实现：

~~~python
class CheckEmail(APIView):
    """验证邮箱是否存在"""
    def get(self, request, email):
        """
        验证邮箱是否存在
        re_path(r"emails/(?P<email>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$)/count/",views.CheckEmail.as_view()),
        :param request:
        :param name:
        :return:
        """
        count = User.objects.filter(email=email)

        data = {
                'email': email,
                'count': count
        }

        return Response(data)
~~~

## 3. 实现用户注册功能:

**后端接口设计:**
请求方式：POST /users/
请求参数: 

|    参数    | 类型 | 是否必传 | 说明         |
| :--------: | :--: | :------: | ------------ |
|  username  | str  |    是    | 用户名       |
|   email    | str  |    是    | 邮箱         |
|  password  | str  |    是    | 密码         |
| password2  | str  |    是    | 确认密码     |
| email_code | str  |    是    | 短息验证码   |
|   allow    | str  |    是    | 是否同意协议 |

返回数据：JSON

|  返回值  | 类型 | 是否必传 |  说明  |
| :------: | :--: | :------: | :----: |
|    id    | int  |    是    | 用户id |
| username | str  |    是    | 用户名 |
|  email   | str  |    是    |  邮箱  |

### 业务逻辑:

- 1.获取前端数据;
- 2.验证数据
  - 序列化器验证;
- 3.保存数据
  - 序列化器保存;
- 4.返回数据

后端代码实现：

~~~python
# views.py

class UserView(CreateAPIView): # 相当于(CreateModelMixin, GenericAPIView)
    """
        实现用户注册功能
        url(r"^users/$", views.UserRegister.as_view()),
        传入的参数:
            allow: "true"
            email: "13711111111"
            password: "11111111"
            password2: "11111111"
            email_code: "261800"
            username: "python"
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer
~~~

~~~python
# serializers.py

import re

from rest_framework import serializers
from .models import User

from verifications.views import EmailCodeView

class UserSerializer(serializers.ModelSerializer):
    """
       用户的序列化器
        allow: "true"
        email: "44@qq.com"
        password: "11111111"
        password2: "11111111"
        email_code: "261800"
        username: "python"
    """
    # 对模型类中没有的字段仅进行反序列化输入
    # write_only:就是用户post过来的数据，后台服务器处理后不会再经过序列化后返回给客户端,我们在使用手机注册的验证码和填写的密码。
    password2 = serializers.CharField(max_length=20, min_length=8, write_only=True)
    email_code = serializers.CharField(max_length=6, min_length=6, write_only=True)
    allow = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields =  ("id","username", "email", "password", "password2", "email_code", "allow")
        extra_kwargs = {
             # 对模型类中的字段添加规则
            'password': {
                'write_only': True,
                'max_length': 20,
                'min_length': 8
            },
            'username': {
                'max_length': 20,
                'min_length': 5
            }
        }

    # 进行字段校验
    '''
    单个字段的验证
    1.在序列化器里定义校验字段的钩子方法   validate_字段
    2.获取字段的数据
    3.验证不通过，抛出异常  raise serializers.ValidationError("错误信息描述")
    4.验证通过，直接返回字段数据
    '''
    def validate_email(self, email):
            """
            验证手机好格式
            :param value: 
            :return: 
            """
            if not re.match(r'\w+@\w+.\w+', email):
                raise serializers.ValidationError("邮箱格式不正确")
            return email

    def validate_allow(self, allow):
            """
            验证是否同意协议
            :param value: 
            :return: 
            """
            if allow != 'true':
                raise serializers.ValidationError("未同意协议")
            
            return allow

    '''
    多个字段的验证
    1.在序列化器定义validate方法
    2.attrs是所有数据组成的字典
    3.不符合抛出异常 raise serializers.ValidationError("校验不通过的说明")
    '''
    def validate(self, attrs):
            """
            验证密码和邮箱验证码
            :param attrs: 
            :return: 
            """
            # 验证密码
            if attrs['password'] != attrs['password2']:
                raise serializers.ValidationError('两次密码不一致')

            # 获取发送的验证码
            real_email_code = EmailCodeView.checkEmailCode(attrs['email']) # 调用类方法
            if real_email_code is None:
                raise serializers.ValidationError('邮箱验证码过期')
            if real_email_code != attrs['email_code'].lower():
                raise serializers.ValidationError('短信验证码错误')

            return attrs

    '''
    自定义验证器
    使用：在字段添加   validators=[自定义验证器,]

    title = serializers.CharField(max_length=32,validators=[my_validate,])             # 使用自定义验证器

    # 自定义验证器
    def my_validate(value):
        if "xxx" in value:
            raise serializers.ValidationError("该字段包含敏感词!!!")
        else:
            return value

    '''         
    # 自定义验证器 > 单个字段的验证 > 多个字段的验证


    def create(self, validated_data):
        """
        保存用户数据
        :param validated_data: 
        :return: 
        """
        # 1.删除无用数据==> 字典删除，因为要创建对象需要将多余的数据删除
        del validated_data['email_code']  # 这几个只是用来校验的
        del validated_data['password2']
        del validated_data['allow']

        # 保存，使用模型类的管理器方法，create_user可以由Django自动将密码加密，而create还需要先将密码自己加密再给
        user = User.objects.create_user(**validated_data)

        # 将保存数据返回
        return user
~~~

~~~python
#验证短信验证码：

class EmailCodeView(APIView):
	"""邮箱验证码业务"""
	
	...
    
    @classmethod
    def checkEmailCode(cls, email):   # 通过@classmethod装饰为类方法，用来判断验证码
        """
        验证邮箱验证码
        :param email: 
        :param email_code: 
        :return: 
        """
        # 建立redis链接
        redis_conn = get_redis_connection(alias='verify_codes')
        email_code_key = 'email_code_key_%s'%email

        real_email = redis_conn.get(email_code_key)            
        return real_email.decode()
~~~

# python学习之美多商城(六):Django REST framework  JWT

## 一、跨域认证的问题

互联网服务离不开用户认证。一般流程是下面这样。

~~~
1、用户向服务器发送用户名和密码。

2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。

3、服务器向用户返回一个 session_id，写入用户的 Cookie。

4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。

5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。
~~~

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。

举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。

## 二、JWT 的原理

JWT(Json web token) 的原理是，服务器认证以后，生成一个token( JSON 对象)，返回给用户，类似下面：

~~~
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"
}
~~~

以后用户与服务端通信的时候，都要携带这个 token。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。

服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。

## 三、JWT 的数据结构

JWT是由三段信息构成的，中间用点（`.`）链接一起就构成了Jwt字符串。就像这样:

~~~
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
~~~

注意，JWT 内部是没有换行的，这里只是编辑器自动换行而已。

JWT 的三个部分依次如下。

头部（header);
载荷（payload, 类似于飞机上承载的物品);
签证（signature)。

即`header.payload.signature`

![1560605644904](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560605644904.png)

##### header

头部Header主要用来声明类型，这里是jwt，并且声明加密算法，通常为HMAC SHA256。

~~~
{
  'typ': 'JWT',
  'alg': 'HS256'
}
~~~

然后将头部进行base64加密(该加密是可以被对称解密的), 构成第一部分。

~~~
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
~~~

##### payload

载荷Payload，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。

- iss (issuer)：签发人
- exp (expiration time)：过期时间
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号

还可以在这个部分定义私有字段

~~~
{
  "sub": "1234567890",
  "name": "xiao ming",
  "admin": true
}
~~~

一般不建议存放敏感信息，这部分也是用base64加密，因为是对称解密的，意味着该部分信息可以归类为明文信息。

##### signature

Signature 部分是对前两部分的签名，防止数据篡改。

首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

~~~
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
~~~

~~~
// javascript
var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);

var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

~~~

将这三部分用 . 连接成一个完整的字符串,构成了最终的jwt：

~~~
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
~~~

## 四、JWT使用

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

~~~
fetch('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
~~~

另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的：

![1560606737799](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560606737799.png)

![1560609576977](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560609576977.png)

## 五、总结

**JWT实现机制：** 即 用户每次请求携带该token，Django进行认证时，会取出header 和payloads部分，并结合Django的秘钥secret_key使用header中声明的加密方式进行加密生成一个新的 signature2，对用户携带的token中的第三部分 signature1进行对比，若用户修改了token则生成的signature2与用户携带的signature1不一致，则无法通过验证。

　　1、是否有token 决定是否进行jwt认证。

　　2、token的正确性决定是否能够通过jwt认证 。

##### 优点

* 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
* 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
* 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。
* 它不需要在服务端保存会话信息, 所以它易于应用的扩展

##### 安全相关

- 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分；
- 保护好secret私钥，该私钥非常重要；
- 如果可以，请使用https协议；



## 六、Django REST framework JWT

##### 安装

~~~
pip install djangorestframework-jwt
~~~

##### 配置

~~~python
REST_FRAMEWORK = {
    # 身份验证
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # drf的这一阶段主要是做验证,middleware的auth主要是设置session和user到request对象
        # 默认的验证是按照验证列表从上到下的验证
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
}
import datetime
JWT_AUTH = {
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1), # 指明token的有效期
}
~~~

##### 使用

有时候你可能希望手动生成令牌，例如在创建帐户后立即将令牌返回给用户。或者，你需要返回的信息不止是Token，可能还有用户权限相关值。使用JWT手动签发token

~~~
from rest_framework_jwt.settings import api_settings

jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

payload = jwt_payload_handler(user)
token = jwt_encode_handler(payload)
~~~

在注册成功后，返回token，需要在注册视图中创建token。修改CreateUserSerializer序列化器，在create方法中增加手动创建token的方法

~~~python
from rest_framework_jwt.settings import api_settings

class CreateUserSerializer(serializers.ModelSerializer):
    """
    创建用户序列化器
    """
    ...
    token = serializers.CharField(label='登录状态token', read_only=True)  # 增加token字段

    class Meta：
        ...
        fields =  ("id","username", "email", "password", "password2", "email_code", "allow", "token")
        ...

   def create(self, validated_data):
        """
        保存用户数据
        :param validated_data: 
        :return: 
        """
        # 1.删除无用数据==> 字典删除，因为要创建对象需要将多余的数据删除
        del validated_data['email_code']  # 这几个只是用来校验的
        del validated_data['password2']
        del validated_data['allow']

        # 保存，使用模型类的管理器方法，create_user可以由Django自动将密码加密，而create还需要先将密码自己加密再给
        user = User.objects.create_user(**validated_data)

        # 补充生成记录登录状态的token
        # 在创建use对象的时候手动生成token
        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)
        user.token = token


        # 将保存数据返回
        return user

~~~

**前端保存token**

我们可以将JWT保存在cookie中，也可以保存在浏览器的本地存储里，我们保存在浏览器本地存储中

浏览器的本地存储提供了sessionStorage 和 localStorage 两种：

- **sessionStorage** 浏览器关闭即失效
- **localStorage** 长期有效

~~~js
sessionStorage.变量名 = 变量值   // 保存数据
sessionStorage.变量名  // 读取数据
sessionStorage.clear()  // 清除所有sessionStorage保存的数据

localStorage.变量名 = 变量值   // 保存数据
localStorage.变量名  // 读取数据
localStorage.clear()  // 清除所有localStorage保存的数据
~~~

在前端js/register.js文件中增加保存token

~~~js
var vm = new Vue({
    ...
    methods: {
        ...
        on_submit: function(){
            axios.post(...)
                .then(response => {
                    // 记录用户的登录状态
                    sessionStorage.clear();
                    localStorage.clear();
                    localStorage.token = response.data.token;
                    localStorage.username = response.data.username;
                    localStorage.user_id = response.data.id;
                    location.href = '/index.html';
                })
                .catch(...)
        }
    }
})
~~~



## jwt在浏览器中的保存位置:

注册成功之后，会保存在

![1560758220796](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560758220796.png)





# python学习之美多商城(七):用户部分--账号登录与多账号登录

# 一、账号登录:

## 1. 业务说明

按照JWT机制，验证用户名和密码，验证成功后，为用户签发JWT，前端将签发的JWT保存下来。

![1560758997150](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560758997150.png)

## 2.后端接口分析:

**请求方式:** POST /users/authorizations/
**请求参数:** JSON或表单

|   参数   | 名类型 | 是否必须 |    说明     |
| :------: | :----: | :------: | :---------: |
| username |  str   |    是    | 用户名/邮箱 |
| password |  str   |    是    |    密码     |

**返回值:**JSON

|  返回值  | 类型 | 是否必须 |         说明          |
| :------: | :--: | :------: | :-------------------: |
| username | str  |    是    |        用户名         |
| user_id  | str  |    是    |        用户id         |
|  token   | str  |    是    | jwt_token(作状态保持) |



## 3.业务分析:

登录后需要JWT token做状态保持，需要获取前端传过来的用户用户名和密码，而在DRF JWT正好提供了验证登录功能。在urls.py中添加以下URL路由以启用通过POST获取令牌包括用户的用户名和密码

![1560760726475](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560760726475.png)

我们在users/urls中，使用JWT提供的`obtain_jwt_token`方法，能够直接实现登录逻辑。

~~~python

from rest_framework_jwt.views import obtain_jwt_token

urlpatterns = [
	...
    path('authorizations/', obtain_jwt_token),
]
~~~

直接访问：

![1560760878107](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560760878107.png)

输入用户和密码之后，返回：

![1560760955745](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560760955745.png)



## 4. 重写JWT的验证方法:



从前端页面登录之后，发现在用户名位置没有显示用户名而是 `undefined`

![1560761235785](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560761235785.png)

这是不能满足需求，通过查看JWT的源码可知，由于jwt返回的信息中只包括凭证token，要想在返回的结果中添加用户信息，需要通过如下配置

~~~python
# users/utils.py
def jwt_response_payload_handler(token, user=None, request=None):
    return {
        'token': token,
        'user_id': user.id,
        'username': user.username
    }

~~~

指定属性，告诉JWT要使用自定义返回参数的方法，进行结果返回

~~~python
JWT_AUTH = {
    # 返回属性设置
    'JWT_RESPONSE_PAYLOAD_HANDLER':
    'users.utils.jwt_response_payload_handler',

    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1),  # 指明token的有效期

}

~~~



![1560762416649](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560762416649.png)

上面是用了JWT自带的认证修改源代码直接返回对应信息，如果不是直接调用自带的路由保持状态，则需要手工签发JWT信息

~~~python
        # 在创建use对象的时候手动生成token
        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)
        user.token = token  # 为user添加token属性才能输出到客户端
        user.user_id = user.id
~~~



## 5. 增加支持用户名与邮箱均可作为登录账号:

JWT扩展的登录视图，在收到用户名与密码时，也是调用Django的认证系统中提供`authenticate`来检查用户与密码是否正确。我们可以修改Django自带的认证方法来支持多账号登录。

**修改Djnago认证系统的认证后端需要继承django.contrib.auth.backends.ModelBackend, 并重写authenticate方法。**

authenticate(self, request, username=None, password=None, **kwargs)方法的参数说明：

- request 本次认证的请求对象
- username 本次认证提供的用户账号
- password 本次认证提供的密码

~~~python
# users/utils.py
class UserBackend(ModelBackend):
    """
    自定义用户名或用户认证
    """
    def authenticate(self, request, username=None, password=None, **kwargs):
        # 使用get需要注意: 如果查询的对象不存在的话，会抛出一个DoesNotExist的异常
        try:
            user = User.objects.get(Q(username=username) | Q(email=username))  # 或查询，注意email是等于username，因为都是从表单username获取的值
            if user.check_password(password):  # 判断密码.使用django的用户模块自带的方法
                return user

        except Exception as e:

            return None
        
~~~

在配置文件中告知Django使用我们自定义的认证后端

~~~python
# 使用自定义的用户模型
AUTH_USER_MODEL = 'users.User'

# 使用自定义的用户验证逻辑
AUTHENTICATION_BACKENDS = [
    'users.utils.UserBackend',
]
~~~





# python学习之美多商城(八):用户模块--第三方登录(QQ登录、微博登录)、创建数据模型类基类

[OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。

简单来说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。

# 一、QQ登录:

QQ登录，亦即我们所说的第三方登录，是指用户可以不在本项目中输入密码，而直接通过第三方的验证，成功登录本项目。

若想实现QQ登录，需要成为QQ互联的开发者，审核通过才可实现。注册方法可参考链接

[http://wiki.open.qq.com/wiki/%E6%B3%A8%E5%86%8C%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85](http://wiki.open.qq.com/wiki/注册成为开发者)

成为QQ互联开发者后，还需创建应用，即获取本项目对应与QQ互联的应用ID，创建应用的方法参考链接http://wiki.connect.qq.com/__trashed-2

创建应用：

<https://connect.qq.com/manage.html#/>

QQ登录开发文档连接http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0

1.前期准备:

![1560869216085](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560869216085.png)

QQ登录获得令牌采用授权码（authorization-code）的方式，具体参考<http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html>

## 2.创建模型类:

创建一个新的应用oauth，用来实现第三方认证登录。**总路由前缀 oauth/**
在meiduo/meiduo_mall/utils/models.py文件中创建模型类基类,用于增加数据新建时间和更新时间。

~~~python
# /utils/models.py
from django.db import models

class BaseModel(models.Model):
    """为模型类补充字段"""
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    update_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        abstract = True  # 说明是抽象模型类, 用于继承使用，数据库迁移时不会创建BaseModel的表

~~~

在oauth/models.py中定义第三方登录model模型类,

~~~python
from django.db import models

from utils.models import BaseModel

class OAuthUser(BaseModel):
    """
        第三方登录基本模型
    """
    TYPE_CHOICES = (('1', 'qq'), ('2', 'weibo'), ('3', 'github'))
    user = models.ForeignKey('users.User', on_delete=models.CASCADE, verbose_name='用户')
    openid = models.CharField(max_length=64, verbose_name='用户标识openid', db_index=True)
    loginType = models.CharField(max_length=1, choices=TYPE_CHOICES)

    class Meta:
        db_table = 'tb_oauth_user'
        verbose_name = '第三方用户登录'
        verbose_name_plural = verbose_name

~~~

## 3. QQ登录实现流程

###### 第一步，网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。

前端提供一个链接，修改`login.js`，在methods中增加`qq_login`方法

~~~js
        // qq登录
        qq_login: function () {
            var next = this.get_query_string('next') || '/';   // 获取当前next参数
            axios.get(this.host + '/oauth/qq/authorization/?next=' + next, {
                responseType: 'json'
            })
                .then(response => {
                    location.href = response.data.login_url;  // 跳转到QQ登录地址
                })
                .catch(error => {
                    console.log(error);

                })
        }
~~~

用户点击这个链接，调用后端接口拼接请求的url地址

~~~python
# oauth/views.py

# 当用户在前端登录界面点击QQ登录按钮后向后端发送请求
class QQAuthURLLoginView(APIView):
    """定义第三方登录的视图类"""
    def get(self, request):
        """
        获取第三方登录链接地址
        :param request:
        :return:
        """
        # 通过request.query_params获取查询字符串，next记录从哪里跳转的
        next = request.query_params.get('next')
        if not next:
            next = "/"

        # 获取QQ登录网页地址
        qq_oauth = OAuth_QQ(client_id=settings.QQ_CLIENT_ID,
                            client_secret=settings.QQ_CLIENT_SECRET,
                            redirect_uri=settings.QQ_REDIRECT_URI,
                            state=next)

        # qq_url = 'https://graph.qq.com/oauth2.0/show?which=Login&display=pc&scope=get_user_info&{0}'
        qq_url = 'https://graph.qq.com/oauth2.0/show?which=Login&display=pc&scope=get_user_info&{0}'

        login_url = qq_oauth.get_auth_url(qq_url)  # 返回QQ登录请求地址

        return Response({"login_url": login_url})

~~~

后端拼接QQ服务器的url地址，返回给前端去请求该URL。

###### 第二步，用户跳转后，B 网站(QQ服务器)会要求用户登录(引导用户输入QQ账号和密码)，然后询问是否同意给予 A 网站授权。如果用户成功登录并授权，则会跳转到`redirect_uri`参数指定的回调地址，并在`redirect_uri`地址后带上Authorization Code和原始的state值。类似：

~~~
http://graph.qq.com/demo/index.jsp?code=9A5F************************06AF&state=test
~~~

以上redirect_uri是在QQ互联平台创建应用配置的回调地址，配置的是直接回调访问前端页面。`code`就是授权码`AUTHORIZATION_CODE` 。

###### 第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。

###### 第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向`redirect_uri`指定的网址，发送一段 JSON 数据。

~~~
{    
  "access_token":"ACCESS_TOKEN",
  "token_type":"bearer",
  "expires_in":2592000,
  "refresh_token":"REFRESH_TOKEN",
  "scope":"read",
  "uid":100101,
  "info":{...}
}
~~~



当QQ回调回网站`qq_oauth_callback.html`，拿到授权码，初始化之后让后端发起请求向QQ服务器请求令牌。

~~~js
    mounted: function () {  // 在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。
        // 从路径中获取qq重定向返回的code
        var code = this.get_query_string('code'); // 要获取到的Authorization Code值
        var state = this.get_query_string('state');
        console.log(code, state);
        axios.get(this.host + '/oauth/qq/user/?code=' + code + '&state=' + state, {
            responseType: 'json',
        }).then(response => {
            if (response.data.user_id) {
                // 用户已绑定
                sessionStorage.clear();
                localStorage.clear();
                localStorage.user_id = response.data.user_id;  // 保存在浏览器本地存储中
                localStorage.username = response.data.username;
                localStorage.token = response.data.token;
                location.href = state;  // 跳转到state
            } else {
                // 用户未绑定
                this.access_token = response.data.access_token;
                this.is_show_waiting = false;
            }
        }).catch(error => {
            console.log(error.response);
            alert('服务器异常');
        })
    }
~~~

后端请求，通过code获取access_token的值，

~~~python

class QQAuthView(APIView):
    """验证QQ登录"""
    def get(self, request):
        """
        第三方登录检查
        :param request:
        :return:
        """
        # 1. 获取code值
        code = request.query_params.get('code')

        # 2. 检查参数
        if not code:
            return Response({'message': '缺少code值'}, status=status.HTTP_400_BAD_REQUEST)


        state = request.query_params.get('state')
        if not state:
            state = '/'

        qq = OAuth_QQ(client_id=settings.QQ_CLIENT_ID,
                            client_secret=settings.QQ_CLIENT_SECRET,
                            redirect_uri=settings.QQ_REDIRECT_URI,
                            state=state)

        url = 'https://graph.qq.com/oauth2.0/token?grant_type=authorization_code&code=' + code + '&state=' + state + '&{0}'

        # 3. 通过code获取access_token的值
        access_token = qq.get_access_token(url)[0]
        print(access_token)

        # 4. 使用AccessToken来获取用户的OpenId
        params = {
            'access_token': access_token
        }

        url = 'https://graph.qq.com/oauth2.0/me?{0}'.format(urllib.parse.urlencode(params))

        openid = qq.get_open_id(url)

        # 5. 判断是否绑定过网站账号
        loginType = '1'

        try:
            qq_user = OAuthUser.objects.get(openid=openid, loginType=loginType)

        except OAuthUser.DoesNotExist:
            # 用户第一次使用QQ登录，未绑定，显示绑定界面
            token = OAuth_QQ.generate_save_user_token(openid)

            return Response({'access_token': token})

        else:
            # 7. 绑定过，则直接登录成功
            # 生成jwt-token值
            user = qq_user.user  # 直接通过外键获取到openid 绑定的用户
            jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER  # 加载生成载荷函数
            jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER  # 加载生成token的函数

            payload = jwt_payload_handler(user)  # 通过传入user对象生成jwt 载荷部分
            token = jwt_encode_handler(payload)  # 传入payload 生成token

            dict_data = {
                'user_id': user.id,
                'username': user.username,
                'token': token
            }

            return Response(dict_data)
~~~

