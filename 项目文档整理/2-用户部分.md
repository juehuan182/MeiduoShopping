# 用户部分--用户模型类(Django自带)、自定义用户模型



# 一、用户模型类

Django提供了认证系统，文档资料可参考此链接https://yiyibooks.cn/xx/Django_1.11.6/topics/auth/index.html

Django认证系统同时处理认证和授权。简单地讲，认证验证一个用户是否它们声称的那个人，授权决定一个通过了认证的用户被允许做什么。 这里的词语“认证”同时指代这两项任务，即Django的认证系统同时提供了认证机制和权限机制。

Django的认证系统包含：

- 用户
- 权限：二元（是/否）标志指示一个用户是否可以做一个特定的任务。
- 组：对多个用户运用标签和权限的一种通用的方式。
- 一个可配置的密码哈希系统
- 用户登录或内容显示的表单和视图
- 一个可插拔的后台系统

Django默认提供的认证系统中，用户的认证机制依赖Session机制，我们在本项目中将引入JWT认证机制，将用户的身份凭据存放在Token中，然后对接Django的认证系统，帮助我们来实现：

- 用户的数据模型
- 用户密码的加密与验证
- 用户的权限系统

## Django用户模型类

Django认证系统中提供了用户模型类User保存用户的数据，默认的User包含以下常见的基本字段：

![1560227819931](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560227819931.png)

### 常用方法:

![1560227856925](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560227856925.png)

### 管理器方法:

管理器方法即可以通过*User.object.*进行调用的方法。

![1560227897339](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560227897339.png)

## 创建自定义的用户模型类:

Django认证系统中提供的用户模型类及方法很方便，我们可以使用这个模型类，但是字段有些无法满足项目需求，如本项目中需要保存用户的邮箱（或者手机号之类），需要给模型类添加额外的字段。

Django提供了django.contrib.auth.models.AbstractUser用户抽象模型类允许我们继承，扩展字段来使用Django认证系统的用户模型类。

在meiduo/meiduo_mall中创建Django应用users

~~~
python manage.py startapp users
~~~



**并在配置文件中注册users应用。**

~~~python
INSTALLED_APPS = [
     ...,
    'users',
]
~~~



在创建好的应用models.py中定义用户的用户模型类。

~~~python
from django.db import models
from django.contrib.auth.models import AbstractUser

# Create your models here.
class User(AbstractUser):
    mobile = models.CharField(max_length=11, unique=True, verbose_name='手机')

    class Meta:
        db_table = 'tb_users'
        verbose_name = '用户'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.username
~~~

我们自定义的用户模型类还不能直接被Django的认证系统所识别，需要在配置文件中告知Django认证系统使用我们自定义的模型类。

在配置文件中进行添加设置

~~~
AUTH_USER_MODEL = 'users.User' # AUTH_USER_MODEL 参数的设置以点.来分隔，表示应用名.模型类名。
~~~

**注意：Django建议我们对于AUTH_USER_MODEL参数的设置一定要在第一次数据库迁移之前就设置好，否则后续使用可能出现未知错误。**

执行数据库迁移:

~~~python
python manage.py makemigrations
python manage.py migrate
~~~

![1560232100153](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560232100153.png)

# 用户部分--注册业务接口分析、跨域CORS、使用celery异步完成发送短信



# 一、注册:

创建好用户模型类后，我们开始来实现第一个业务逻辑——用户注册

* 分析要实现的业务逻辑，明确在这个业务中需要涉及到几个相关子业务，将每个子业务当做一个接口来设计。
* 分析接口的功能任务，明确接口的访问方式与返回数据：
  * 接口的请求方式，如GET 、POST 、PUT等
  * 接口的URL路径定义
  * 需要前端传递的数据及数据格式（如路径参数、查询字符串、请求体表单、JSON等）
  * 返回给前端的数据及数据格式



**特别强调**：在前后端分离的应用模式中，我们作为后端开发人员设计后端接口时，可以不用考虑返回给前端数据后，前端如何处理，这是前端开发人员的工作，我们只需明确我们要保存的或者要返回的是什么数据即可。

## 2.注册业务接口分析:

![1560232445389](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560232445389.png)

在用户注册中,需要实现以下接口:

- 短信验证码;
- 用户名判断是否存在;
- 手机号判断是否存在;
- 注册保存用户数据;





# 二、短信验证码:

短信验证功能可以归属为第三方功能,所以**创建一个新应用verifications，在此应用中实现短信验证码**

~~~python
python manage.py startapp verifications
~~~



## 1. 业务处理流程:

- 1.生成和发送短信验证码;
- 2.保存短信验证码;
- 3.redis pipline的使用;
- 4.检查是否在60s内有发送记录;
- 5.celery异步发送短信;

## 2. 后端接口设计:

请求方式: GET /email_codes/(?P<email>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/
请求参数: 路径参数

| 参数  | 类型 | 是否必须说明 | 说明 |
| :---: | :--: | :----------: | :--: |
| email | str  |      是      | 邮箱 |

返回数据:json

返回值|类型|是否必传|说明
:-:|:-:|:-:|:-:
message|str|否|OK,发送成功|

## 3.后端实现:

verifications/views.py中

~~~python
import logging

from django.shortcuts import render
from django_redis import get_redis_connection

from rest_framework.views import APIView 
from rest_framework.response import Response
from rest_framework import status


# Create your views here.

logger = logging.getLogger('django')


class EmailCodeView(APIView):
    """发送邮件验证码"""
    def get(self, request, email):
        """
            发送邮件验证码
            re_path(r"^sms_codes/(?P<email>1[3-9]\d{9})/$", views.SMSCodeView.as_view()),
            :param request:
            :param mobile: 路径传参的手机号
            :return:       
        """
        # 1. 创建redis链接
        redis_conn = get_redis_connection(alias='verify_codes')

        # 2.判断60m内是否不允许重复发送短信
        email_flag_key = 'send_flag_key_%s'%email
        email_flag = redis_conn.get(email_flag_key)
        if email_flag:
            return Response({'message':'发送短信过于频繁'}, status=status.HTTP_400_BAD_REQUEST)

        # 3. 生成验证码
        import random
        send_code = random.randint(100000, 999999)
        logger.info(send_code)

        # 发送邮件，调用发送邮件接口
        import send_email
        # 发送验证码给邮箱
        #  1. 同步发送邮件
        result = send_email.send_email_code(email, 'register')
        if result:
            return Response({'message':'OK'})
        else:
            return Response({'message':'验证码发送失败，请重新发送！'}, status=status.HTTP_400_BAD_REQUEST)

~~~

但是,实现到这里,似乎一切都没有错，但是前端的请求却不能被后端接收或者接收返回给前端走的是error。

这里我们来测试下，前端文件夹有个测试页面test.html

~~~html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/jquery-1.12.4.min.js"></script>
    <script src="js/axios-0.18.0.min.js"></script>
</head>
<body>
<input type="button" value="show" id="show">
</body>
</html>
<script>
    $('#show').click(function () {
        axios.get('http://127.0.0.1:8000/test/')
            .then(response=>{
                console.log('ok')
            }).catch(error=>{
                console.log('no')
        });
    });
</script>
~~~



我们启动前端服务，进入front_end_pc执行命令live-server启动前端，输入<http://127.0.0.1:8080/test.html>

并发送请求，后端代码子目录meiduo_mall/views.py

~~~python
from django.shortcuts import render
from rest_framework.views import APIView
from rest_framework.response import Response


class TestView(APIView):
    def get(self, request):
        print('I am coming')
        return Response({'message':'接收OK'})
~~~

启动后端程序，进入根目录meiduo_mall下

~~~py
python manage.py runserver 127.0.0.1:8000
~~~

发送请求：

![1560268660832](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560268660832.png)

查看打印的日志报错CORS跨域问题

![1560269040837](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560269040837.png)原因就是我们使用前后端分离的模式, 所以需要做跨域访问。

## 4.关于跨域访问:



浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。比如我有一个A网站，我现在想通过Ajax来得到B网站上的某些内容，A和B是在不同域中，这时就会出现跨域问题。或者比如，站点 http://domain-a.com 的某 HTML 页面通过 [ 的 src ](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Img#Attributes)请求 http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。或者可以正常发起跨站请求，但是返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。

跨域资源共享（ [CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS) ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。

## 5.设置域名:

现在为前端和后端扥别设置两个不同的域名:

| 位置 |      域名      |
| :--: | :------------: |
| 前端 | www.meiduo.com |
| 后端 | api.meiduo.com |

在hosts文件中添加2调信息

~~~
127.0.0.1   api.meiduo.com
127.0.0.1   www.meiduo.com
~~~

* windows系统在`C:\Windows\System32\drivers\etc`目录中
* linux系统中`cat /etc/hosts`

# 三、跨域CORS:

我们为前端和后端分别设置了两个不同的域名

| 位置 |      域名      |
| :--: | :------------: |
| 前端 | www.meiduo.com |
| 后端 | api.meiduo.com |

**现在，前端与后端分处不同的域名，我们需要为后端添加跨域访问的支持。**
我们使用CORS来解决后端对跨域访问的支持。使用django-cors-headers扩展

#### 1. 安装:

~~~python
pip install django-cors-headers
~~~

#### 2.添加应用

~~~python
INSTALLED_APPS = [
    ...
    'corsheaders',
    ...
]
~~~

#### 3.中间件设置

~~~python
MIDDLEWARE = [
    # 注意这个放在其他中间件的最上面
   'corsheaders.middleware.CorsMiddleware',
    ...
]
~~~

#### 4.添加白名单

~~~python
# CORS
CORS_ORIGIN_WHITELIST = (  # 凡是出现在白名单中的域名，都可以访问后端接口
    'http://127.0.0.1:8080',
    'http://localhost:8080',
    'http://www.meiduo.com:8080',
    'http://api.meiduo.com:8000'
)
CORS_ALLOW_CREDENTIALS = True  # 指明在跨域访问中，后端是否支持对cookie的操作。
~~~

#### 5.测试

![1560317396520](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560317396520.png)



正常访问了。至此跨域问题得到处理；

# 四、使用celery异步完成发送短信:

## 1. celery介绍:

Celery是基于Python开发的一个分布式任务队列框架，支持使用任务队列的方式在分布的机器/进程/线程上执行任务调度。即插即用，易于使用和维护，单个进程每分钟可以处理数百万个任务。

![1560317721681](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560317721681.png)

![img](https://upload-images.jianshu.io/upload_images/9286065-b7d030bb829d75c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp)





## 2. celery的安装:

~~~python
pip install celery
~~~

## 3.celery使用:

在meiduo/meiduo_mall下(manage.py同级)创建celery_tasks用于保存celery异步任务。

* 在celery_tasks目录下创建config.py文件，用于保存celery的配置信息。

~~~python
# Broker配置，使用Redis作为消息中间件，存放broker消息队列
broker_url = "redis://127.0.0.1:6379/4"
# BACKEND配置，这里使用redis，存放执行结果
result_backend = "redis://127.0.0.1:6379/5"
~~~

* 在celery_tasks目录下创建main.py文件，用于作为celery的启动文件

~~~python
# 为celery使用django配置文件进行设置

import os
from celery import Celery

# 设置django环境，celery 运行时需要读取django中的信息
# if not os.getenv('DJANGO_SETTINGS_MODULE'):
#     os.environ['DJANGO_SETTINGS_MODULE'] = 'meiduo_mall.settings.dev

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'meiduo_mall.settings.dev')

# 创建celery应用, 创建一个Celery类的实例对象
app = Celery('meiduo')

#  导入celery配置
app.config_from_object('celery_tasks.config')

# 自动注册celery任务
app.autodiscover_tasks(['celery_tasks.email', ])
~~~

在celery_tasks目录下创建email目录，用于放置发送邮件的异步任务相关代码。

将提供的发送邮件的代码放到celery/email/send_email.py目录下

~~~python
import random
import logging

from django.core.mail import send_mail
from django_redis import get_redis_connection
from django.conf import settings

from verifications import constants


# 导入日志器
logger = logging.getLogger('django')


# 定义一个发送邮件
def send_email_code(email, email_code, send_type):


    subject = ''  # 主题
    text_message = ''  # 正文
    html_message = ''  # html格式正文

    if send_type == 'register':
        # print('register')
        subject = u'全民python-注册验证码'
        text_message = u'【全民python】您的注册验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！'.format(email_code)  # text格式
        html_message = u'【全民python】您的注册验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！'.format(email_code)  # html格式方便点击链接

    elif send_type == 'resetpwd':
        subject = u'全民python-找回密码验证码'
        text_message = u'【全民python】找回登录密码的验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！'.format(email_code)
        html_message = u'<p>【全民python】找回登录密码的验证码：{0}，请勿将此验证码告知他人，若非本人操作，请联系或者忽略，3分钟内有效！</p>'.format(email_code)
    else:
        subject = ''
        text_message = ''
        html_message = ''

    # # 保存缓存
    # # mcache.set_key(email, code.lower(), 120)
    # conn_redis = get_redis_connection(alias='verify_codes')

    # # 创建一个在60s以内是否有发送邮件记录的标记
    # email_flag_key = "email_flag_key_{}".format(email).encode('utf-8')

    # # 创建保存邮箱验证码的标记key
    # email_code_key = "email_code_key{}".format(email).encode('utf-8')

    # # 在此处设置为True会出现bug
    # try:
    #     # 使用redis管道pipeline，优化redis交互，减少通信次数，
    #     # 创建redis管道对象
    #     pl = conn_redis.pipeline()

    #     # 将验证码和是否发送标记存储到redis中

    #     pl.setex(email_flag_key, constants.SEND_CODE_INTERVAL, 1)  # 是否已发送标志
    #     pl.setex(email_code_key, constants.EMAIL_CODE_REDIS_EXPIRES, email_code.lower())  # 保存验证码
    #     # 让管道通知redis执行命令
    #     pl.execute()
    # except Exception as e:
    #     logger.debug("redis 执行出现异常:{}".format(e))
    #     return None

    logger.info("email code:{}".format(email_code))
    logger.info("EMAIL_FROM:{}".format(settings.EMAIL_FROM))

    send_status = send_mail(subject, text_message, settings.EMAIL_FROM, [email], html_message)  # 如果提供了html_message，可以发送带HTML代码的邮件。
    print('send_status%s' %send_status)
    return send_status


'''
1.单发send_mail()方法返回值将是成功发送出去的邮件数量（只会是0或1，因为它只能发送一封邮件）。
2.群发 send_mass_mail()，用来处理大批量邮件任务。返回值是成功发送的邮件数量。
使用send_mail()方法时，每调用一次，它会和SMTP服务器建立一次连接，也就是发一次连一次，效率很低。
而send_mass_mail()，则只建立一次链接，就将所有的邮件都发送出去，效率比较高。

需要提醒的是，接收方的邮件服务商不一定支持多媒体邮件，可能为了安全，也许是别的原因。
为了保证邮件内容能被阅读，最好2种格式一起发送纯文本邮件。
'''
~~~

在celery_tasks/email/目录下创建tasks.py文件，用于保存发送邮件的异步任务

~~~python
import logging
from meiduo_mall.celery_tasks.main import app

logger = logging.Logger('django')

# 创建任务函数
@app.task(name='send_email_code')
def task_send_email_code(email, email_code, send_type):  
    """
    发送邮件验证码的任务
    :param email:
    :param email_code:
    :return:
    """
    try:
        send_status = send_email.send_email_code(email, email_code, send_type)
    except Exception as e:
        logger.error("发送邮件验证码[异常][ email: %s, message: %s ]" % (email, e))

    else: # 如果try里面的语句可以正常执行，那么就执行else里面的语句（相当于程序没有碰到致命性错误）
        if send_status:  # 成功返回1，不成功返回0或者报错
            logger.info("发送邮件验证码[正常][ email: %s, email_code: %s ]" % (email, email_code))
        else:
            logger.warning("发送邮件验证码[失败][ email: %s ]" % email)

~~~

将调用发送邮件的地方改成celery异步发送

~~~python
class EmailCodeView(APIView):
    """发送邮件验证码"""
    def get(self, request, email):
        """
            发送邮件验证码
            re_path(r"^sms_codes/(?P<email>1[3-9]\d{9})/$", views.SMSCodeView.as_view()),
            :param request:
            :param mobile: 路径传参的手机号
            :return:       
        """
        send_type = request.query_params.dict().get('send_type')
        print(send_type)

        # 1. 创建redis链接
        redis_conn = get_redis_connection(alias='verify_codes')

        # 2.判断60m内是否不允许重复发送短信
        email_flag_key = 'email_flag_key_{}'.format(email)
        email_flag = redis_conn.get(email_flag_key)
        print(email_flag)
        if email_flag:
            return Response({'message': '发送邮件过于频繁'}, status=status.HTTP_400_BAD_REQUEST)

        # 3. 生成验证码
        if send_type == 'register':
            code_len = 6
        elif send_type == 'resetpwd':
            code_len = 6
        else:
            code_len = 4

        email_code = self.random_str(code_len)


        logger.info(email_code)

        email_code_key = 'email_code_key_{}'.format(email)
        print(email_code_key)

        # 发送邮件，调用发送邮件接口
        #from celery_tasks.email import send_email
        # 发送验证码给邮箱
        # #  1. 同步发送邮件
        # result = send_email.task_send_email_code(email, 'register')
        # if result:
        #     return Response({'message':'OK'})
        # else:
        #     return Response({'message':'验证码发送失败，请重新发送！'}, status=status.HTTP_400_BAD_REQUEST)
        # 2. 使用celery异步发送邮件，调用delay
        task_send_email_code.delay(email, email_code, send_type)

        print("邮箱验证码:%s" % email_code)       

            # 在此处设置为True会出现bug
        try:
            # 使用redis管道pipeline，优化redis交互，减少通信次数，
            # 创建redis管道对象
            pl = redis_conn.pipeline()
            
            # 将验证码和是否发送标记存储到redis中

            from verifications import constants

            pl.setex(email_flag_key, constants.SEND_CODE_INTERVAL, 1)  # 是否已发送标志
            pl.setex(email_code_key, constants.EMAIL_CODE_REDIS_EXPIRES, email_code.lower())  # 保存验证码
            # 让管道通知redis执行命令
            pl.execute()
        except Exception as e:
            logger.debug("redis 执行出现异常:{}".format(e))
            return Response({'message': 'redis 执行出现异常:{}'.format(e)})

        return Response({'message': 'OK'})

~~~



切换到项目根目录meiduo_mall下，执行命令启动worker。启动celery异步任务:

~~~
celery -A celery_tasks.main worker -l info
~~~

启动 celery 服务，通过它来监听是否有任务要处理。这个命令启动了一个worker，用来执行程序中add这个加法任务（task）。

* -A 选项指定 celery 实例 app 的位置，本例中celery_tasks.main中自动寻找，当然可以直接指定 celery worker -A task.app -l info
*  -l 选项指定日志级别， -l 是 --loglevel 的缩略形式
* 其他更多选项通过 celery worker –-help 查看

![1560356568617](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560356568617.png)

**注意** ：有个坑，当时email目录是之间建立的文件夹，而不是python包导致(即没有\__init__.py文件)导致获取任务为空。花了半个小时排查，蓦然回首，那人却在灯火阑珊处！！

发送邮件的时候报错：

![1560666905649](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560666905649.png)

win10上运行celery4.x就会出现这个问题，解决办法如下

先安装一个``eventlet`

~~~
pip install eventlet
~~~

然后启动worker的时候加一个参数，如下：

~~~
celery -A celery_tasks.main worker -l info -P eventlet
~~~





# python学习之美多商城(五):用户部分--判断账号/用户名/手机号是否重复、注册

# 一、判断账号是否存在:

## 1. 判断用户名是否存在:

**后端接口设计:**
请求方式:GET usernames/(?P<username>\w{5,20})/count/
请求参数: 路径传参

参数|类型|是否必传|说明
:-:|:-:|:-:|:-:|
username|str|是|用户名

返回数据：JSON

|  返回值  | 类型 | 是否必传 |  说明  |
| :------: | :--: | :------: | :----: |
| username | str  |    是    | 用户名 |
|  count   | int  |    是    |  数量  |

返回数据示例：

~~~
{
	"username":"qmpython",
	"count":1
}
~~~

后端代码实现：

~~~python
class CheckUsername(APIView):
    """验证用户名是否重复"""
    def get(self, request, username):
        """
        验证用户名是否重复
        path(r"usernames/(?P<username>\w{5,20})/count/",views.CheckUsername.as_view()),
        :param request:
        :param name:
        :return:
        """
        count = User.objects.filter(username=username)

        data = {
                'username': username,
                'count': count
        }

        return Response(data)
~~~

## 2. 判断邮箱是否存在

**后端接口设计:**
请求方式：GET emails/(?P<email>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$)/count/
请求参数: 路径参数

| 参数  | 类型 | 是否必传 | 说明 |
| :---: | :--: | :------: | :--: |
| email | str  |    是    | 邮箱 |

返回数据：JSON

| 返回值 | 类型 | 是否必传 | 说明 |
| :----: | :--: | :------: | :--: |
| email  | str  |    是    | 邮箱 |
| count  | int  |    是    | 数量 |

返回数据示例：

~~~
{
	"email":"44@qq.com",
	"count":0
}

~~~

后端实现：

~~~python
class CheckEmail(APIView):
    """验证邮箱是否存在"""
    def get(self, request, email):
        """
        验证邮箱是否存在
        re_path(r"emails/(?P<email>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$)/count/",views.CheckEmail.as_view()),
        :param request:
        :param name:
        :return:
        """
        count = User.objects.filter(email=email)

        data = {
                'email': email,
                'count': count
        }

        return Response(data)
~~~

## 3. 实现用户注册功能:

**后端接口设计:**
请求方式：POST /users/
请求参数: 

|    参数    | 类型 | 是否必传 | 说明         |
| :--------: | :--: | :------: | ------------ |
|  username  | str  |    是    | 用户名       |
|   email    | str  |    是    | 邮箱         |
|  password  | str  |    是    | 密码         |
| password2  | str  |    是    | 确认密码     |
| email_code | str  |    是    | 短息验证码   |
|   allow    | str  |    是    | 是否同意协议 |

返回数据：JSON

|  返回值  | 类型 | 是否必传 |  说明  |
| :------: | :--: | :------: | :----: |
|    id    | int  |    是    | 用户id |
| username | str  |    是    | 用户名 |
|  email   | str  |    是    |  邮箱  |

### 业务逻辑:

- 1.获取前端数据;
- 2.验证数据
  - 序列化器验证;
- 3.保存数据
  - 序列化器保存;
- 4.返回数据

后端代码实现：

~~~python
# views.py

class UserView(CreateAPIView): # 相当于(CreateModelMixin, GenericAPIView)
    """
        实现用户注册功能
        url(r"^users/$", views.UserRegister.as_view()),
        传入的参数:
            allow: "true"
            email: "13711111111"
            password: "11111111"
            password2: "11111111"
            email_code: "261800"
            username: "python"
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer
~~~

~~~python
# serializers.py

import re

from rest_framework import serializers
from .models import User

from verifications.views import EmailCodeView

class UserSerializer(serializers.ModelSerializer):
    """
       用户的序列化器
        allow: "true"
        email: "44@qq.com"
        password: "11111111"
        password2: "11111111"
        email_code: "261800"
        username: "python"
    """
    # 对模型类中没有的字段仅进行反序列化输入
    # write_only:就是用户post过来的数据，后台服务器处理后不会再经过序列化后返回给客户端,我们在使用手机注册的验证码和填写的密码。
    password2 = serializers.CharField(max_length=20, min_length=8, write_only=True)
    email_code = serializers.CharField(max_length=6, min_length=6, write_only=True)
    allow = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields =  ("id","username", "email", "password", "password2", "email_code", "allow")
        extra_kwargs = {
             # 对模型类中的字段添加规则
            'password': {
                'write_only': True,
                'max_length': 20,
                'min_length': 8
            },
            'username': {
                'max_length': 20,
                'min_length': 5
            }
        }

    # 进行字段校验
    '''
    单个字段的验证
    1.在序列化器里定义校验字段的钩子方法   validate_字段
    2.获取字段的数据
    3.验证不通过，抛出异常  raise serializers.ValidationError("错误信息描述")
    4.验证通过，直接返回字段数据
    '''
    def validate_email(self, email):
            """
            验证手机好格式
            :param value: 
            :return: 
            """
            if not re.match(r'\w+@\w+.\w+', email):
                raise serializers.ValidationError("邮箱格式不正确")
            return email

    def validate_allow(self, allow):
            """
            验证是否同意协议
            :param value: 
            :return: 
            """
            if allow != 'true':
                raise serializers.ValidationError("未同意协议")
            
            return allow

    '''
    多个字段的验证
    1.在序列化器定义validate方法
    2.attrs是所有数据组成的字典
    3.不符合抛出异常 raise serializers.ValidationError("校验不通过的说明")
    '''
    def validate(self, attrs):
            """
            验证密码和邮箱验证码
            :param attrs: 
            :return: 
            """
            # 验证密码
            if attrs['password'] != attrs['password2']:
                raise serializers.ValidationError('两次密码不一致')

            # 获取发送的验证码
            real_email_code = EmailCodeView.checkEmailCode(attrs['email']) # 调用类方法
            if real_email_code is None:
                raise serializers.ValidationError('邮箱验证码过期')
            if real_email_code != attrs['email_code'].lower():
                raise serializers.ValidationError('短信验证码错误')

            return attrs

    '''
    自定义验证器
    使用：在字段添加   validators=[自定义验证器,]

    title = serializers.CharField(max_length=32,validators=[my_validate,])             # 使用自定义验证器

    # 自定义验证器
    def my_validate(value):
        if "xxx" in value:
            raise serializers.ValidationError("该字段包含敏感词!!!")
        else:
            return value

    '''         
    # 自定义验证器 > 单个字段的验证 > 多个字段的验证


    def create(self, validated_data):
        """
        保存用户数据
        :param validated_data: 
        :return: 
        """
        # 1.删除无用数据==> 字典删除，因为要创建对象需要将多余的数据删除
        del validated_data['email_code']  # 这几个只是用来校验的
        del validated_data['password2']
        del validated_data['allow']

        # 保存，使用模型类的管理器方法，create_user可以由Django自动将密码加密，而create还需要先将密码自己加密再给
        user = User.objects.create_user(**validated_data)

        # 将保存数据返回
        return user
~~~

~~~python
#验证短信验证码：

class EmailCodeView(APIView):
	"""邮箱验证码业务"""
	
	...
    
    @classmethod
    def checkEmailCode(cls, email):   # 通过@classmethod装饰为类方法，用来判断验证码
        """
        验证邮箱验证码
        :param email: 
        :param email_code: 
        :return: 
        """
        # 建立redis链接
        redis_conn = get_redis_connection(alias='verify_codes')
        email_code_key = 'email_code_key_%s'%email

        real_email = redis_conn.get(email_code_key)            
        return real_email.decode()
~~~

# python学习之美多商城(六):Django REST framework  JWT

## 一、跨域认证的问题

互联网服务离不开用户认证。一般流程是下面这样。

~~~
1、用户向服务器发送用户名和密码。

2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。

3、服务器向用户返回一个 session_id，写入用户的 Cookie。

4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。

5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。
~~~

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。

举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。

## 二、JWT 的原理

JWT(Json web token) 的原理是，服务器认证以后，生成一个token( JSON 对象)，返回给用户，类似下面：

~~~
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"
}
~~~

以后用户与服务端通信的时候，都要携带这个 token。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。

服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。

## 三、JWT 的数据结构

JWT是由三段信息构成的，中间用点（`.`）链接一起就构成了Jwt字符串。就像这样:

~~~
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
~~~

注意，JWT 内部是没有换行的，这里只是编辑器自动换行而已。

JWT 的三个部分依次如下。

头部（header);
载荷（payload, 类似于飞机上承载的物品);
签证（signature)。

即`header.payload.signature`

![1560605644904](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560605644904.png)

##### header

头部Header主要用来声明类型，这里是jwt，并且声明加密算法，通常为HMAC SHA256。

~~~
{
  'typ': 'JWT',
  'alg': 'HS256'
}
~~~

然后将头部进行base64加密(该加密是可以被对称解密的), 构成第一部分。

~~~
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
~~~

##### payload

载荷Payload，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。

- iss (issuer)：签发人
- exp (expiration time)：过期时间
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号

还可以在这个部分定义私有字段

~~~
{
  "sub": "1234567890",
  "name": "xiao ming",
  "admin": true
}
~~~

一般不建议存放敏感信息，这部分也是用base64加密，因为是对称解密的，意味着该部分信息可以归类为明文信息。

##### signature

Signature 部分是对前两部分的签名，防止数据篡改。

首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

~~~
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
~~~

~~~
// javascript
var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);

var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

~~~

将这三部分用 . 连接成一个完整的字符串,构成了最终的jwt：

~~~
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
~~~

## 四、JWT使用

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

~~~
fetch('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
~~~

另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的：

![1560606737799](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560606737799.png)

![1560609576977](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560609576977.png)

## 五、总结

**JWT实现机制：** 即 用户每次请求携带该token，Django进行认证时，会取出header 和payloads部分，并结合Django的秘钥secret_key使用header中声明的加密方式进行加密生成一个新的 signature2，对用户携带的token中的第三部分 signature1进行对比，若用户修改了token则生成的signature2与用户携带的signature1不一致，则无法通过验证。

　　1、是否有token 决定是否进行jwt认证。

　　2、token的正确性决定是否能够通过jwt认证 。

##### 优点

* 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
* 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
* 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。
* 它不需要在服务端保存会话信息, 所以它易于应用的扩展

##### 安全相关

- 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分；
- 保护好secret私钥，该私钥非常重要；
- 如果可以，请使用https协议；



## 六、Django REST framework JWT

##### 安装

~~~
pip install djangorestframework-jwt
~~~

##### 配置

~~~python
REST_FRAMEWORK = {
    # 身份验证
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # drf的这一阶段主要是做验证,middleware的auth主要是设置session和user到request对象
        # 默认的验证是按照验证列表从上到下的验证
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
}
import datetime
JWT_AUTH = {
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1), # 指明token的有效期
}
~~~

##### 使用

有时候你可能希望手动生成令牌，例如在创建帐户后立即将令牌返回给用户。或者，你需要返回的信息不止是Token，可能还有用户权限相关值。使用JWT手动签发token

~~~
from rest_framework_jwt.settings import api_settings

jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

payload = jwt_payload_handler(user)
token = jwt_encode_handler(payload)
~~~

在注册成功后，返回token，需要在注册视图中创建token。修改CreateUserSerializer序列化器，在create方法中增加手动创建token的方法

~~~python
from rest_framework_jwt.settings import api_settings

class CreateUserSerializer(serializers.ModelSerializer):
    """
    创建用户序列化器
    """
    ...
    token = serializers.CharField(label='登录状态token', read_only=True)  # 增加token字段

    class Meta：
        ...
        fields =  ("id","username", "email", "password", "password2", "email_code", "allow", "token")
        ...

   def create(self, validated_data):
        """
        保存用户数据
        :param validated_data: 
        :return: 
        """
        # 1.删除无用数据==> 字典删除，因为要创建对象需要将多余的数据删除
        del validated_data['email_code']  # 这几个只是用来校验的
        del validated_data['password2']
        del validated_data['allow']

        # 保存，使用模型类的管理器方法，create_user可以由Django自动将密码加密，而create还需要先将密码自己加密再给
        user = User.objects.create_user(**validated_data)

        # 补充生成记录登录状态的token
        # 在创建use对象的时候手动生成token
        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)
        user.token = token


        # 将保存数据返回
        return user

~~~

**前端保存token**

我们可以将JWT保存在cookie中，也可以保存在浏览器的本地存储里，我们保存在浏览器本地存储中

浏览器的本地存储提供了sessionStorage 和 localStorage 两种：

- **sessionStorage** 浏览器关闭即失效
- **localStorage** 长期有效

~~~js
sessionStorage.变量名 = 变量值   // 保存数据
sessionStorage.变量名  // 读取数据
sessionStorage.clear()  // 清除所有sessionStorage保存的数据

localStorage.变量名 = 变量值   // 保存数据
localStorage.变量名  // 读取数据
localStorage.clear()  // 清除所有localStorage保存的数据
~~~

在前端js/register.js文件中增加保存token

~~~js
var vm = new Vue({
    ...
    methods: {
        ...
        on_submit: function(){
            axios.post(...)
                .then(response => {
                    // 记录用户的登录状态
                    sessionStorage.clear();
                    localStorage.clear();
                    localStorage.token = response.data.token;
                    localStorage.username = response.data.username;
                    localStorage.user_id = response.data.id;
                    location.href = '/index.html';
                })
                .catch(...)
        }
    }
})
~~~



## jwt在浏览器中的保存位置:

注册成功之后，会保存在

![1560758220796](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560758220796.png)





# python学习之美多商城(七):用户部分--账号登录与多账号登录

# 一、账号登录:

## 1. 业务说明

按照JWT机制，验证用户名和密码，验证成功后，为用户签发JWT，前端将签发的JWT保存下来。

![1560758997150](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560758997150.png)

## 2.后端接口分析:

**请求方式:** POST /users/authorizations/
**请求参数:** JSON或表单

|   参数   | 名类型 | 是否必须 |    说明     |
| :------: | :----: | :------: | :---------: |
| username |  str   |    是    | 用户名/邮箱 |
| password |  str   |    是    |    密码     |

**返回值:**JSON

|  返回值  | 类型 | 是否必须 |         说明          |
| :------: | :--: | :------: | :-------------------: |
| username | str  |    是    |        用户名         |
| user_id  | str  |    是    |        用户id         |
|  token   | str  |    是    | jwt_token(作状态保持) |



## 3.业务分析:

登录后需要JWT token做状态保持，需要获取前端传过来的用户用户名和密码，而在DRF JWT正好提供了验证登录功能。在urls.py中添加以下URL路由以启用通过POST获取令牌包括用户的用户名和密码

![1560760726475](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560760726475.png)

我们在users/urls中，使用JWT提供的`obtain_jwt_token`方法，能够直接实现登录逻辑。

~~~python

from rest_framework_jwt.views import obtain_jwt_token

urlpatterns = [
	...
    path('authorizations/', obtain_jwt_token),
]
~~~

直接访问：

![1560760878107](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560760878107.png)

输入用户和密码之后，返回：

![1560760955745](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560760955745.png)



## 4. 重写JWT的验证方法:



从前端页面登录之后，发现在用户名位置没有显示用户名而是 `undefined`

![1560761235785](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560761235785.png)

这是不能满足需求，通过查看JWT的源码可知，由于jwt返回的信息中只包括凭证token，要想在返回的结果中添加用户信息，需要通过如下配置

~~~python
# users/utils.py
def jwt_response_payload_handler(token, user=None, request=None):
    return {
        'token': token,
        'user_id': user.id,
        'username': user.username
    }

~~~

指定属性，告诉JWT要使用自定义返回参数的方法，进行结果返回

~~~python
JWT_AUTH = {
    # 返回属性设置
    'JWT_RESPONSE_PAYLOAD_HANDLER':
    'users.utils.jwt_response_payload_handler',

    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1),  # 指明token的有效期

}

~~~



![1560762416649](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560762416649.png)

上面是用了JWT自带的认证修改源代码直接返回对应信息，如果不是直接调用自带的路由保持状态，则需要手工签发JWT信息

~~~python
        # 在创建use对象的时候手动生成token
        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)
        user.token = token  # 为user添加token属性才能输出到客户端
        user.user_id = user.id
~~~



## 5. 增加支持用户名与邮箱均可作为登录账号:

JWT扩展的登录视图，在收到用户名与密码时，也是调用Django的认证系统中提供`authenticate`来检查用户与密码是否正确。我们可以修改Django自带的认证方法来支持多账号登录。

**修改Djnago认证系统的认证后端需要继承django.contrib.auth.backends.ModelBackend, 并重写authenticate方法。**

authenticate(self, request, username=None, password=None, **kwargs)方法的参数说明：

- request 本次认证的请求对象
- username 本次认证提供的用户账号
- password 本次认证提供的密码

~~~python
# users/utils.py
class UserBackend(ModelBackend):
    """
    自定义用户名或用户认证
    """
    def authenticate(self, request, username=None, password=None, **kwargs):
        # 使用get需要注意: 如果查询的对象不存在的话，会抛出一个DoesNotExist的异常
        try:
            user = User.objects.get(Q(username=username) | Q(email=username))  # 或查询，注意email是等于username，因为都是从表单username获取的值
            if user.check_password(password):  # 判断密码.使用django的用户模块自带的方法
                return user

        except Exception as e:

            return None
        
~~~

在配置文件中告知Django使用我们自定义的认证后端

~~~python
# 使用自定义的用户模型
AUTH_USER_MODEL = 'users.User'

# 使用自定义的用户验证逻辑
AUTHENTICATION_BACKENDS = [
    'users.utils.UserBackend',
]
~~~





# python学习之美多商城(八):用户模块--第三方登录(QQ登录、微博登录)、创建数据模型类基类

[OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。

简单来说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。

# 一、QQ登录:

QQ登录，亦即我们所说的第三方登录，是指用户可以不在本项目中输入密码，而直接通过第三方的验证，成功登录本项目。

若想实现QQ登录，需要成为QQ互联的开发者，审核通过才可实现。注册方法可参考链接

[http://wiki.open.qq.com/wiki/%E6%B3%A8%E5%86%8C%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85](http://wiki.open.qq.com/wiki/注册成为开发者)

成为QQ互联开发者后，还需创建应用，即获取本项目对应与QQ互联的应用ID，创建应用的方法参考链接http://wiki.connect.qq.com/__trashed-2

创建应用：

<https://connect.qq.com/manage.html#/>

QQ登录开发文档连接http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0

1.前期准备:

![1560869216085](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560869216085.png)

QQ登录获得令牌采用授权码（authorization-code）的方式，具体参考<http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html>

## 2.创建模型类:

创建一个新的应用oauth，用来实现第三方认证登录。**总路由前缀 oauth/**
在meiduo/meiduo_mall/utils/models.py文件中创建模型类基类,用于增加数据新建时间和更新时间。

~~~python
# /utils/models.py
from django.db import models

class BaseModel(models.Model):
    """为模型类补充字段"""
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    update_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        abstract = True  # 说明是抽象模型类, 用于继承使用，数据库迁移时不会创建BaseModel的表

~~~

在oauth/models.py中定义第三方登录model模型类,

~~~python
from django.db import models

from utils.models import BaseModel

class OAuthUser(BaseModel):
    """
        第三方登录基本模型
    """
    TYPE_CHOICES = (('1', 'qq'), ('2', 'weibo'), ('3', 'github'))
    user = models.ForeignKey('users.User', on_delete=models.CASCADE, verbose_name='用户')
    openid = models.CharField(max_length=64, verbose_name='用户标识openid', db_index=True)
    loginType = models.CharField(max_length=1, choices=TYPE_CHOICES)

    class Meta:
        db_table = 'tb_oauth_user'
        verbose_name = '第三方用户登录'
        verbose_name_plural = verbose_name

~~~

## 3. QQ登录实现流程

###### 第一步，网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。

#### 返回QQ登录网站视图

**请求方式：** GET /oauth/qq/authorization/

**请求参数：** 查询字符串

| 参数名 | 类型 | 是否必须 |                  说明                  |
| :----: | :--: | :------: | :------------------------------------: |
|  next  | str  |    否    | 用户QQ登录成功后进入美多商城的哪个网址 |

**返回数据：**JSON

|  返回值   | 类型 | 是否必传 |    说明    |
| :-------: | :--: | :------: | :--------: |
| login_url | str  |    是    | qq登录网址 |

~~~json
{
    "login_url": "https://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=101474184&redirect_uri=http%3A%2F%2Fwww.meiduo.site%3A8080%2Foauth_callback.html&state=%2F&scope=get_user_info"
}

~~~

### 前端的逻辑实现:

前端提供一个链接，在methods中增加`qq_login`方法，修改`login.js`

```js
        // qq登录
        qq_login: function () {
            var next = this.get_query_string('next') || '/';   // 获取当前next参数
            axios.get(this.host + '/oauth/qq/authorization/?next=' + next, {
                responseType: 'json'
            })
                .then(response => {
                    location.href = response.data.login_url;  // 跳转到QQ登录地址
                })
                .catch(error => {
                    console.log(error);

                })
        }
```

用户点击这个链接，调用后端API拼接请求QQ服务器的url地址

### 后端的逻辑实现:

~~~python
# oauth/views.py

# 当用户在前端登录界面点击QQ登录按钮后向后端发送请求
class QQAuthURLLoginView(APIView):
    """定义第三方登录的视图类"""
    def get(self, request):
        """
        获取第三方登录链接地址
        :param request:
        :return:
        """
        # 通过request.query_params获取查询字符串，next记录从哪里跳转的
        next = request.query_params.get('next')
        if not next:
            next = "/"

        # 获取QQ登录网页地址
        qq_oauth = OAuth_QQ(client_id=settings.QQ_CLIENT_ID,
                            client_secret=settings.QQ_CLIENT_SECRET,
                            redirect_uri=settings.QQ_REDIRECT_URI,
                            state=next)

        # qq_url = 'https://graph.qq.com/oauth2.0/show?which=Login&display=pc&scope=get_user_info&{0}'
        qq_url = 'https://graph.qq.com/oauth2.0/show?which=Login&display=pc&scope=get_user_info&{0}'

        login_url = qq_oauth.get_auth_url(qq_url)  # 返回QQ登录请求地址

        return Response({"login_url": login_url})

~~~

将拼接好的URL地址，返回给前端，让前端去请求QQ服务器。

###### 第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。如果用户成功登录并授权，则会跳转到`redirect_uri`参数指定的回调地址，并在`redirect_uri`地址后带上Authorization Code和原始的state值。

前端去跳转到QQ服务器

~~~
location.href = response.data.login_url;  // 跳转到QQ登录地址
~~~

QQ引导用户输入QQ账号和密码，客户成功登录并授权之后，则会通过传递的回调地址，回调回我们网站`qq_oauth_callback.html`，类似

~~~
http://www.qmpython.com:8001/qq_authon?code=9A5F************************06AF&state=test
~~~

以上redirect_uri是在QQ互联平台创建应用配置的回调地址，配置的是直接回调访问前端页面。`code`就是授权码`AUTHORIZATION_CODE` 。

###### 第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。

回调到我们网站请求的是`qq_oauth_callback.html`，前端拿到授权码，初始化之后让后端发起请求向QQ服务器请求令牌。

### 前端逻辑实现：

~~~js
 mounted: function () {  // 在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。
        // 从路径中获取qq重定向返回的code
        var code = this.get_query_string('code'); // 要获取到的Authorization Code值
        var state = this.get_query_string('state');
        console.log(code, state);
        axios.get(this.host + '/oauth/qq/user/?code=' + code + '&state=' + state, {
            responseType: 'json',
        }).then(response => {
            if (response.data.user_id) {
                // 用户已绑定
                sessionStorage.clear();
                localStorage.clear();
                localStorage.user_id = response.data.user_id;  // 保存在浏览器本地存储中
                localStorage.username = response.data.username;
                localStorage.token = response.data.token;
                location.href = state;  // 跳转到state
            } else {
                // 用户未绑定
                alert(response.data.bind_token);
                this.bind_token = response.data.bind_token;
                this.is_show_waiting = false;
            }
        }).catch(error => {
            console.log(error.response);
            alert('服务器异常');
        })
    },
~~~

后端请求，通过code获取access_token的值。

####  后端接口:

**请求方式:** GET  /oauth/qq/user/
**请求参数:** 查询字符串

| 参数  | 类型 | 是否必传 |         说明         |
| :---: | :--: | :------: | :------------------: |
| code  | str  |    是    |  qq返回的授权码code  |
| state | str  |    否    | qq授权登录后跳转地址 |

**返回数据：**JSON

|    参数    | 类型 | 是否必传 |                             说明                             |
| :--------: | :--: | :------: | :----------------------------------------------------------: |
| bind_token | str  |    否    | 用户是第一次使用QQ登录时返回，其中包含openid，用于绑定身份使用，用于判断有效期，注意这个是我们自己生成的 |
|   token    | str  |    否    |     用户不是第一次使用QQ登录时返回，登录成功的JWT token      |
|  username  | str  |    否    |            用户不是第一次使用QQ登录时返回，用户名            |
|  user_id   | int  |    否    |            用户不是第一次使用QQ登录时返回，用户id            |

~~~json
{
    "bind_token": xxxx,
}
或
{
    "token": "xxx",
    "username": "python",
    "user_id": 1
}
~~~

####  后端逻辑实现:

~~~python

class QQAuthView(APIView):
    """验证QQ登录"""
    def get(self, request):
        """
        第三方登录检查
        :param request:
        :return:
        """
        # 1. 获取code值
        code = request.query_params.get('code')

        # 2. 检查参数
        if not code:
            return Response({'message': '缺少code值'}, status=status.HTTP_400_BAD_REQUEST)


        state = request.query_params.get('state')
        if not state:
            state = '/'

        qq = OAuth_QQ(client_id=settings.QQ_CLIENT_ID,
                            client_secret=settings.QQ_CLIENT_SECRET,
                            redirect_uri=settings.QQ_REDIRECT_URI,
                            state=state)

        url = 'https://graph.qq.com/oauth2.0/token?grant_type=authorization_code&code=' + code + '&state=' + state + '&{0}'

        # 3. 通过code获取access_token的值
        access_token = qq.get_access_token(url)[0]
        print(access_token)

        # 4. 使用AccessToken来获取用户的OpenId
        params = {
            'access_token': access_token
        }

        url = 'https://graph.qq.com/oauth2.0/me?{0}'.format(urllib.parse.urlencode(params))

        openid = qq.get_open_id(url)

        # 5. 判断是否绑定过网站账号
        loginType = '1'

        try:
            qq_user = OAuthUser.objects.get(openid=openid, loginType=loginType)

        except OAuthUser.DoesNotExist:
            # 用户第一次使用QQ登录，未绑定，显示绑定界面
            bind_token = OAuth_QQ.generate_save_user_token(openid)

            return Response({'bind_token': bind_token})

        else:
            # 7. 绑定过，则直接登录成功
            # 生成jwt-token值
            user = qq_user.user  # 直接通过外键获取到openid 绑定的用户
            jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER  # 加载生成载荷函数
            jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER  # 加载生成token的函数

            payload = jwt_payload_handler(user)  # 通过传入user对象生成jwt 载荷部分
            token = jwt_encode_handler(payload)  # 传入payload 生成token

            dict_data = {
                'user_id': user.id,
                'username': user.username,
                'token': token
            }

            return Response(dict_data)


~~~

###### 第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向`redirect_uri`指定的网址，发送一段 JSON 数据。

```
{    
  "access_token":"ACCESS_TOKEN",
  "token_type":"bearer",
  "expires_in":2592000,
  "refresh_token":"REFRESH_TOKEN",
  "scope":"read",
  "uid":100101,
  "info":{...}
}
```

得到第三方用户的数据，QQ中获取openid，然后绑定网站账户。

## OpenID绑定美多商城用户

如果用户是首次使用QQ登录，则需要绑定用户，页面如下：

![1560927975163](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560927975163.png)



业务逻辑：

用户需要填写手机号、密码、短信验证码
如果用户未在美多商城注册过，则会将手机号作为用户名为用户创建一个美多账户，并绑定用户
如果用户已在美多商城注册过，则检验密码后直接绑定用户

用户信息填写完点击保存

 ### 前端实现逻辑

~~~js
 on_submit: function () {
            this.check_pwd();
            this.check_email();
            this.check_email_code();

            if (this.error_password == false &&
                this.error_email == false &&
                this.error_email_code == false) {
                axios.post(this.host + '/oauth/qq/user/', {
                    password: this.password,
                    email: this.email,
                    email_code: this.email_code,
                    bind_token: this.bind_token,
                    login_type: '1'
                }, {
                    responseType: 'json',
                })
                    .then(response => {
                        // 记录用户登录状态
                        sessionStorage.clear();
                        localStorage.clear();
                        localStorage.token = response.data.token;
                        localStorage.user_id = response.data.id;
                        localStorage.username = response.data.username;
                        location.href = this.get_query_string('state');
                    })
                    .catch(error => {
                        if (error.response.status == 400
                        ) {
                            this.error_email_code_message = error.response.data.message;
                            this.error_email_code = true;
                        } else {
                            console.log(error.response.data);
                        }
                    })
            }
        }
~~~



###  后端接口设计

**请求方式:** POST /oauth/qq/user/

**请求参数:** JSON 或 表单

|    参数    | 类型 | 是否必须 |        说明        |
| :--------: | :--: | :------: | :----------------: |
|   email    | str  |    是    |        邮箱        |
|  password  | str  |    是    |        密码        |
| email_code | str  |    是    |     短信验证码     |
| bind_token | str  |    是    | 凭据 （包含openid) |
| login_type | str  |    是    |   第三方账户类型   |

**返回数据：** JSON

|  返回值  | 类型 | 是否必须 |   说明    |
| :------: | :--: | :------: | :-------: |
|  token   | str  |    是    | JWT token |
| user_id  | int  |    是    |  用户id   |
| username | str  |    是    |  用户名   |

### 后盾逻辑实现:

* 在oauth/views.py修改QQAuthUserView视图：

~~~python
class QQOauthView(APIView):
    """验证QQ登录"""
    def get(self,request):
        ...
        
    def post(self, request):
        """
        QQ绑定页面的请求，完成绑定用户操作
        :param request:
        :return:
        """
        # 1. 获取前端数据
        data = request.data
        # 2. 创建序列化器进行反序列操作
        verified_data = OAuthSerializer(data=data)  # 反序列化传的是data，注意区分
        # 校验数据
        if verified_data.is_valid():
            verified_data.save()
            # print(verified_data.data) # 需要保存之后才能获取.data
            return Response(verified_data.data)

        return Response(verified_data.errors, status=status.HTTP_400_BAD_REQUEST)
~~~

- 在oauth/serializers.py中定义序列化器:

  ~~~python
  import re
  from verifications.views import EmailCodeView
  
  from django.db.models import Q
  from rest_framework import serializers
  from rest_framework_jwt.settings import api_settings
  
  from users.models import User
  from oauth.models import OAuthUser
  
  from .utils import OAuthBase
  
  class OAuthSerializer(serializers.ModelSerializer):
      """第三方账户绑定的序列化器"""
      # 指定模型类中没有的字段
      email_code = serializers.CharField(max_length=6, min_length=6, write_only=True)
      bind_token = serializers.CharField(write_only=True)  # 反序列化输入，可能要进行校验之类的。注意这个是我们自己生成的。
      login_type = serializers.CharField(write_only=True)
  
      token = serializers.CharField(label='登录状态token', read_only=True)  # 定义只输出的token属性
      user_id = serializers.IntegerField(read_only=True)  # 序列化输出
  
      class Meta:
          model = User
          fields = ('password', 'email', 'username', 'email_code', 'token', 'bind_token', 'login_type', 'user_id')
          extra_kwargs = {
              'username': {
                  'read_only': True  # 只是输出
              },
              'email': {
                  'write_only': True  # 只是输入，不输出
              },
              'password': {
                  'write_only': True,
                  'min_length': 8,
                  'max_length': 20,
                  'error_messages': {
                      'min_length': '仅允许8-20个字符的密码',
                      'max_length': '仅允许8-20个字符的密码',
                  }
              }
          }
  
      def validate_email(self, email):
              """
              验证邮箱格式
              :param value:
              :return:
              """
              if not re.match(r'\w+@\w+.\w+', email):
                  raise serializers.ValidationError("邮箱格式不正确")
              return email
  
      def validate(self, attrs):
          """
          验证access_token
          :param attrs:
          :return:
          """
          # 校验access_token
          bind_token = attrs['bind_token']
          openid = OAuthBase.check_save_user_token(bind_token)
          if not openid:
              raise serializers.ValidationError('无效的bind_token')
  
          attrs['openid'] = openid
  
          # 校验验证码
          # 获取发送的验证码
          real_email_code = EmailCodeView.checkEmailCode(attrs['email'])  # 调用类方法
          if real_email_code is None:
              raise serializers.ValidationError('邮箱验证码过期')
          if real_email_code != attrs['email_code'].lower():
              raise serializers.ValidationError('短信验证码错误')
  
          # 校验第三方登录类型
          login_type = attrs['login_type']
          if not login_type:
              raise serializers.ValidationError('登录类型错误')
  
          # 校验用户名和邮箱是否被注册过
  
          user = User.objects.filter(Q(username=attrs['email'])|Q(email=attrs['email'])).first()
          if user: # 注册过，则检查密码是否正确
              if not user.check_password(attrs['password']):
                  raise serializers.ValidationError('密码错误')
  
              attrs['user'] = user
  
          return attrs
  
      def create(self, validated_data):
          """
          保存用户
          :param validated_data:
          :return:
          """
          # 判断用户
          user = validated_data.get('user')
          if not user:
              # 创建新用户
              email = validated_data.get('email')
              password = validated_data.get('password')
  
              user = User.objects.create_user(username=email, email=email,  password=password)
  
  
          # 用户与第三方账户绑定
          OAuthUser.objects.create(user=user, openid=validated_data.get('openid'), loginType=validated_data.get('login_type'))
  
          # 签发jwt token
          # 在创建use对象的时候手动生成token
          jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
          jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
          payload = jwt_payload_handler(user)
          token = jwt_encode_handler(payload)
          user.token = token  # 为user添加token属性才能输出到客户端
          user.user_id = user.id
          return user
  
  ~~~

  

# python学习之美多商城(九):用户模块--用户中心个人信息、邮件验证、celery异步实现发送邮件

# 一、用户中心个人信息:

前端访问个人信息页面时，需要向后端请求个人信息。
在本页面中要显示用户的Email邮箱信息，而对于邮箱信息我们要实现对于邮箱的验证功能，并在本页面中显示邮箱是否已验证，如下所示，





## 后端接口设计:

**请求方式:** GET /user/
**请求参数:** token(headers中)
**返回数据:** JSON

|  返回值  | 类型 | 是否必须 |   说明    |
| :------: | :--: | :------: | :-------: |
|    id    | int  |    是    |  用户id   |
| username | str  |    是    |  用户名   |
|  email   | str  |    是    | email邮箱 |

## 后端代码实现:

**定义一个序列化器,用来序列化返回用户数据**

~~~python
# users/serializers.py

class UserDetailSerializer(serializers.Serializer):
    """
    用户详细信息序列化器
    """
    id = serializers.IntegerField(read_only=True) # 用户id，只输出
    username = serializers.CharField(min_length=5, max_length=20, error_messages={'min_length': "用户名不能少于5个字符",
                                                                                  'max_length': "用户名不能大于20个字符",})

    email = serializers.EmailField(read_only=True)
~~~



~~~python
# users/views.py
# path('user/detail/', UserDetailView.as_view(), name='user_detail'),

class UserDetailView(RetrieveAPIView):  # RetrieveAPIView 详情视图扩展
    """用户详情"""
    queryset = User.objects.all()   # 获取查询集
    serializer_class = UserDetailSerializer  # 序列化类
    from rest_framework.permissions import IsAuthenticated
    permission_classes = [IsAuthenticated]   # 局部设置权限认证

    def get_object(self):
        """
        重写get_object,不使用pk值返回user
        因为查看某个对象具体详情，默认URL是需要配置类似
            path('users/<int:pk>/', UserDetailView.as_view(), name='user_detail'),
            但是这里我们没有使用Pk
        :return:
        """
        return self.request.user

~~~

**注意：访问视图必须要求用户已通过认证（即登录之后）**



其他修改，这里没有实现，可参考使用修改通过视图类进行处理。



# python学习之美多商城(十):用户模块--用户中心收货地址、省市区三级联动、使用缓存保存省市区、用户地址管理

# 收货地址:

![1560934982245](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560934982245.png)



在这个页面中，我们要实现用户地址的管理，主要的业务逻辑有：

- 省市区地址的数据库建立与查询
- 用户地址的增删改查处理
- 设置默认地址
- 设置地址标题

# 一、省市区三级联动:

![1560934921707](C:\Users\44801\AppData\Roaming\Typora\typora-user-images\1560934921707.png)

## 1.三级联动：

在用户输入地址时，需要进行省市区的选择，在页面加载时，向后端请求省份数据，当用户选择确定省份后，向后端请求对应城市数据，用户选择城市后，向后端请求该城市区县信息，这个过程就称为省市区三级联动。

## 2.数据库建表：

新建一个应用areas来实现省市区三级联动。

~~~python
python manage.py startapp areas
~~~

在areas/models.py中,我们创建省市区数据表,采用自关联的方式。

~~~python

class Area(models.Model):
    """
    省市区
    """
    name = models.CharField(max_length=20, verbose_name='名称')
    parent = models.ForeignKey('self', on_delete=models.SET_NULL, related_name='subs', null=True,
                               blank=True, verbose_name='上级行政区')  # 省是顶级，所以null和blank为空。
    '''
    province=Area.objects.get(pk=1)
    province.parent:获取上级对象
    province.***_set:获取下级对象--改名-->province.subs
    '''

    class Meta:
        db_table = 'tb_areas'
        verbose_name = '行政区域'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name
~~~

### 2.1自关联说明

- 自关联字段的外键指向自身，所以ForeignKey(‘self’)
- 需要使用related_name指明查询一个行政区划的所有下级行政区划时，使用哪种语法查询，如本模型类中指明通过Area模型类对象.subs查询所有下属行政区划，而不是使用Django默认的Area模型类对象.area_set语法。

## 3.导入数据到数据库:

迁移到数据库后,我们向数据库中添加[全国省市区数据,将areas.sql导入数据库](https://download.csdn.net/download/qq_35709559/10869443)

~~~
# mysql -h数据库ip地址 -u数据库用户名 -p数据库密码 数据库 < areas.sql
mysql -h127.0.0.1 -umeiduo -pmeiduo meiduo_mall < areas.sql
~~~

## 4.后端实现:

### 4.1 请求省份数据

**请求方式:** GET areas/
**请求参数:** 无
**返回数据:**JSON

| 返回值 | 类型 | 是否必须 |   说明   |
| :----: | :--: | :------: | :------: |
|   id   | int  |    是    |  省份id  |
|  name  | str  |    是    | 省份名称 |

~~~json
[
    {
        "id": 110000,
        "name": "北京市"
    },
    {
        "id": 120000,
        "name": "天津市"
    },
    {
        "id": 130000,
        "name": "河北省"
    },
    ...
]
~~~

**业务逻辑:**

- 查询省信息
- 结果返回

### 4.2 请求城市或区县的数据

**请求方式:** GET   /areas/\<int:id\>/
**请求参数:** 路径传参

| 参数 | 类型 | 是否必传 |      说明      |
| :--: | :--: | :------: | :------------: |
|  id  | int  |    是    | 父级行政区划id |

**返回数据:**JSON

| 参数 | 类型 | 是否必传 |        说明        |
| :--: | :--: | :------: | :----------------: |
|  id  | int  |    是    |  当前行政区划的id  |
| name | str  |    是    | 当前行政区划的名称 |



~~~json
[
{"id":140100,"name":"太原市"},
{"id":140200,"name":"大同市"},
{"id":140300,"name":"阳泉市"},
...
]
~~~

**业务逻辑:**

- 获取id
- 查询市/区信息
- 返回结果

### 4.3 后端代码实现:

序列化实现数据的序列化

~~~python
class AreaSerializer(serializers.ModelSerializer):
    """
    行政区划信息序列化器
    """
    class Meta:
        model = Area
        fields = ['id', 'name']


class SubAreaSerializer(serializers.ModelSerializer):
    """
    子行政区划信息序列化器
    省和市单一序列化器
    """
    # 默认关系属性只输出主键,可以通过指定序列化器来指定输出的格式，嵌套序列
    # 查询上一级的所有子级
    subs = AreaSerializer(many=True, read_only=True)  # 反向查询序列字段中需要用related_name或者子表小写表名_set

    class Meta:
        model = Area
        fields = ['id', 'name', 'subs']
~~~

视图类中的实现

~~~python
from rest_framework.viewsets import ReadOnlyModelViewSet

from .models import Area
from .serializers import AreaSerializer, SubAreaSerializer

class AreasViewSet(ReadOnlyModelViewSet):
    """
    使用省市区数据查询
    """

    pagination_class = None  # 禁用分页，商品功能有全局分页

    # 指定查询集
    # queryset = Area.objects.filter(parent_id=None)  # 过滤查询，返回父级为空的数据
    def get_queryset(self):
        if self.action == 'list':
            # 查询所有的省的数据
            return Area.objects.filter(parent_id=None)
        else:
            # 查询指定PK的数据，查询范围是如下指定
            return Area.objects.all()

    # 指定序列化器
    # serializer_class = AreaSerializer
    # 当进行GET,无pk时,查询所有省信息,使用AreaSerializer
    # 当进行GET,pk时,查询指定pk的数据并输出子地区信息,使用SubAreaSerializer
    def get_serializer_class(self):
        if self.action == 'list':
            return AreaSerializer   # 列表视图使用
        else:
            return SubAreaSerializer    # 详情视图使用
~~~

ReadOnlyModelViewSet只读视图集。



路由配置

~~~python
from django.urls import path

from rest_framework.routers import DefaultRouter

from .views import AreasViewSet

app_name = 'areas'

# 视图集的路由生成
router = DefaultRouter()
router.register('', AreasViewSet, base_name='areas')

urlpatterns = [

]

urlpatterns += router.urls
~~~

# 二、使用缓存:

省市区的数据是经常被用户查询使用的，而且数据基本不变化，所以我们可以将省市区数据进行缓存处理，减少数据库的查询次数。

在Django REST framework中使用缓存，可以通过drf-extensions扩展来实现。

## 1.安装:

~~~
pip install drf-extensions
~~~

## 2.使用方法:

### 2.1使用drf-extensions提供的扩展类:

drf-extensions扩展对于缓存提供了三个扩展类,三个扩展类都是在rest_framework_extensions.cache.mixins中:

* ListCacheResponseMixin
  用于缓存返回列表数据的视图,与ListModelMixin扩展类配合使用,实际是为list方法添加了cache_response装饰器。

* RetrieveCacheResponseMixin
  用于缓存返回单一数据的视图,与RetrieveModelMixin扩展类配合使用,实际是为了retrieve方法添加了chche_response装饰器。

* CahceResponseMixin

  为视图集同时补充List和Retrieve两种缓存,与ListModelMixin一起配合使用。

## 3. 为省市区视图添加缓存:

**因为省市区视图使用了视图集,并且视图集中有提供ListModelMixin和RetrieveModelMixin的扩展(由ReadOnlyModelViewSet提供 ),所以可以直接添加CacheRespponseMixin扩展类。**

修改返回省市区信息的视图:

~~~python
class AreasViewSet(CacheResponseMixin, ReadOnlyModelViewSet): # CacheResponseMixin放在第一位
    """
    使用省市区数据查询
    """

    pagination_class = None  # 禁用分页，商品功能有全局分页

    # 指定查询集
    # queryset = Area.objects.filter(parent_id=None)  # 过滤查询，返回父级为空的数据
    def get_queryset(self):
        if self.action == 'list':
            # 查询所有的省的数据
            return Area.objects.filter(parent_id=None)
        else:
            # 查询指定PK的数据，查询范围是如下指定
            return Area.objects.all()

    # 指定序列化器
    # serializer_class = AreaSerializer
    # 当进行GET,无pk时,查询所有省信息,使用AreaSerializer
    # 当进行GET,pk时,查询指定pk的数据并输出子地区信息,使用SubAreaSerializer
    def get_serializer_class(self):
        if self.action == 'list':
            return AreaSerializer   # 列表视图使用
        else:
            return SubAreaSerializer    # 详情视图使用
~~~

### 4.缓存数据保存位置与有效期的设置:

~~~python
# DRF 扩展
REST_FRAMEWORK_EXTENSIONS = {
    # 缓存有效时间, 单位是秒
    'DEFAULT_CACHE_RESPONSE_TIMEOUT': 60 * 60,
    # 缓存存储
    'DEFAULT_USE_CACHE': 'default', # cache 缓存使用的Django缓存后端（即CACHES配置中的键名称）,这里使用的是default这个
}

~~~

# 三、用户地址管理:

我们为保存用户的地址信息,创建数据库表,在users/models.py中定义模型类:

~~~python

class Address(BaseModel):
    """
    用户地址
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='addresses', verbose_name='用户')
    receiver = models.CharField(max_length=20, verbose_name='收货人')
    province = models.ForeignKey('areas.Area', on_delete=models.PROTECT, related_name='province_addresses', verbose_name='省')
    city = models.ForeignKey('areas.Area', on_delete=models.PROTECT, related_name='city_addresses', verbose_name='市')
    district = models.ForeignKey('areas.Area', on_delete=models.PROTECT, related_name='district_addresses', verbose_name='区')
    place = models.CharField(max_length=50, verbose_name='详细地址')
    mobile = models.CharField(max_length=11, verbose_name='手机')
    tel = models.CharField(max_length=20, null=True, blank=True, default='', verbose_name='固定电话')
    email = models.CharField(max_length=30, null=True, blank=True, default='', verbose_name='电子邮箱')
    is_deleted = models.BooleanField(default=False, verbose_name='逻辑删除')

    class Meta:
        db_table = 'tb_address'
        # 默认是按照id排序,可以指定为按照修改时间降序排列
        ordering = ['-update_time']

        verbose_name = '收获地址'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.place
"""
    Address模型类中的外键指向Areas / models里面的Area，指明外键ForeignKey时，可以使用字符串应用名.模型类名来定义
    related_name
    在进行反向关联查询时使用的属性，如
    city = models.ForeignKey(‘areas.Area’, related_name =‘city_addresses’)表示可以通过Area对象.city_addresses属性获取所有相关的city数据。
    ordering
    表名在进行Address查询时，默认使用的排序方式
    models.PROTECT: 保护模式，如果采用该选项，删除的时候，会抛出ProtectedError错误。
"""
~~~

为User模型类添加默认地址：

~~~python
class User(AbstractUser):
    ...
    # 这里外键关联的是下面定义的，如果不用引号则会陷入循环调用不到的，因为他们2个彼此调用对方，所以用引号可以解决这问题。
    default_address = models.ForeignKey('Address', related_name='users', null=True, blank=True,
                                        on_delete=models.SET_NULL, verbose_name='默认地址')
	...
~~~

# 四 、用户地址管理代码

## 1.添加和修改用户收件地址：





